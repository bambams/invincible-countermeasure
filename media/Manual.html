<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta content="text/html; charset=utf-8" http-equiv="content-type"><title>Manual</title><style type="text/css">
html {
  background-color: #226699;
}
body {
  background-color: #226699;
  color: white;
  font-family: Arial,Helvetica,sans-serif;
}
*:link {
  color: #66cccc;
}
*:link:active {
  color: #9999ff;
}
*:link:visited {
  color: #ddffdd;
}
.excode {
  border-width: medium;
  padding: 2px 0px 4px 8px;
  visibility: visible;
  font-size: medium;
  display: block;
  margin-left: 32px;
  background-color: #2277aa;
  line-height: normal;
}
.list {
  border-left-style: hidden;
  border-left-width: 10px;
  border-top-width: 10px;
  border-top-style: hidden;
}
h1 {
  font-size: 1.3em;
  display: block;
  margin-left: 0px;
  padding-left: 12px;
  background-color: #6666cc;
  padding-bottom: 4px;
  padding-top: 6px;
  font-weight: bold;
}
h2 {
  display: block;
  margin-left: 0px;
  padding-left: 12px;
  padding-bottom: 4px;
  padding-top: 6px;
  font-weight: bold;
  background-color: #3388dd;
  font-size: 1.1em;
}
h3 {
  display: block;
  margin-left: 0px;
  padding-left: 12px;
  padding-bottom: 4px;
  padding-top: 6px;
  background-color: #227799;
  font-size: 1.1em;
  font-weight: normal;
}
.method {
  font-weight: bold;
  display: block;
  margin-left: 0px;
  padding-left: 12px;
  background-color: #226666;
  padding-bottom: 4px;
  padding-top: 6px;
}

</style></head>
<body style="color: white; background-color: rgb(34, 102, 153);" alink="#33ffff" link="#66cccc" vlink="#339999">
<div style="text-align: left;"><big style="font-weight: bold;"><big><big>Invincible
Countermeasure</big></big></big><br>
</div>
<br>Copyright 2015 Linley Henzell<br><br>
Version: beta 2<br>
<br>
<h1><a class="mozTocH1" name="mozTocId524339"></a><span class="chapter"> 1. Introduction</span></h1>
<br>
Invincible Countermeasure is a game of defending/infiltrating
computer systems
(although it&nbsp;won't teach you anything about how to do this in
the real
world). It has singleplayer modes and also supports play-by-email
multiplayer;&nbsp;networked multiplayer may be implemented sometime
in
the future.<br>
<br>
This is the manual. Fortunately, you don't need to read it to play the
game - it's mostly a detailed reference for advanced players, so if you
just want to play then start up the game and play the tutorials and
missions.
You can get basic help about what most of the buttons and other objects
in the menu interface (although not currently the game interface) by
right-clicking on them with your mouse.<br><br>You can also change some of the game's settings (like the size of the
game window, fullscreen, sound volume etc) by editing init.txt.<br>
<br>
Invincible Countermeasure&nbsp;is licensed under the GPL v3 (or
later), and source
code is available online. To build it you will need a C compiler (I use
gcc) with the Allegro 5 library (I have 5.0.10;&nbsp; 5.1 may work as well). See the comments in
m_main.c for more information about building the game.<br><br><span style="font-weight: bold;"><br>A note on security</span><br><br>This
game executes user-supplied bytecode inside a simple virtual machine.
I've done my best to make sure everything the bytecode interpreter
does&nbsp;is bounds-checked,&nbsp;heavily supervised and as far away
from system calls as practicable. But I'm not a
professional&nbsp;programmer and I can't guarantee that the virtual
machine is bulletproof when running unknown code by other people,
especially
in its current state as an untested beta. Exercise discretion when
running other people's processes etc, particularly in bcode form!<br><br>See also the Disclaimer and Limitation clauses of the GPL (in licence.txt in the main game directory).<br>
<br>
<span style="font-weight: bold;"><br>
Contents</span><br>
<ul id="mozToc">
<!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6--><li><a href="#mozTocId524339"> 1. Introduction</a></li>
<li><a href="#mozTocId65966"> 2. Basic things</a>
<ul>
<li><a href="#mozTocId768458"> 2.1 Types of
programs</a>
<ul>
<li><a href="#mozTocId912976"> 2.1.1
Processes</a></li>
<li><a href="#mozTocId420242">2.1.2 System
programs</a></li>
<li><a href="#mozTocId369045">2.1.3
Observer programs</a></li>
<li><a href="#mozTocId587352">2.1.4 Client
programs</a></li>
<li><a href="#mozTocId287138">2.1.5 Client
(operator)</a></li>
<li><a href="#mozTocId395479">2.1.6 Client
(delegate)</a></li>
</ul>
</li>
<li><a href="#mozTocId748685">2.2 Templates</a></li>
<li><a href="#mozTocId683651">2.3 Code editor</a></li>
<li><a href="#mozTocId240196">2.4 Menu
interface</a></li>
</ul>
</li>
<li><a href="#mozTocId681248">3. Playing the game</a>
<ul>
<li><a href="#mozTocId784123"> 3.1 Missions</a></li>
<li><a href="#mozTocId468133"> 3.2 Starting
from a system file</a></li>
<li><a href="#mozTocId690224">3.3 Multiplayer</a></li>
<li><a href="#mozTocId983110">3.4 Programs you
can use</a></li>
</ul>
</li>
<li><a href="#mozTocId983713">4. Compiler</a>
<ul>
<li><a href="#mozTocId381621">4.1 Some C
keywords that work differently</a></li>
<li><a href="#mozTocId408522"> 4.2 Processes
and sub-processes</a></li>
<li><a href="#mozTocId883339">4.3 Preprocessor</a></li>
<li><a href="#mozTocId588312"> 4.4 Memory and
registers</a></li>
<li><a href="#mozTocId353779">4.5 Built-in
functions</a>
<ul>
<li><a href="#mozTocId831569">4.5.1 Basic
built-in functions</a></li>
<li><a href="#mozTocId917365">4.5.2
Method-based built-in functions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mozTocId282111"> 5. Interfaces</a>
<ul>
<li><a href="#mozTocId530141"> 5.1 Process
interface</a></li>
<li><a href="#mozTocId636847">5.2
Client/observer program interface</a></li>
<li><a href="#mozTocId951354">5.3 System
program interface</a></li>
<li><a href="#mozTocId484629"> 5.4 More on
process interfaces: shapes and sizes</a></li>
<li><a href="#mozTocId813054"> 5.5 The process
data box</a></li>
</ul>
</li>
<li><a href="#mozTocId329052"> 6. Methods</a>
<ul>
<li><a href="#mozTocId627354"> 6.1 Process
methods (PR)</a></li>
<li><a href="#mozTocId277936"> 6.2 Client
methods (CL)</a></li>
<li><a href="#mozTocId6563"> 6.3
Client/Observer methods (CLOB)</a></li>
<li><a href="#mozTocId281352"> 6.4 Observer
methods (OB)</a></li>
<li><a href="#mozTocId325090"> 6.5 System
methods (SY)</a></li>
</ul>
</li>
<li><a href="#mozTocId292376"> 7. Bcode and the
assembler</a>
<ul>
<li><a href="#mozTocId401392">7.1 Assembly
instructions and operands</a>
<ul>
<li><a href="#mozTocId555544">7.1.1
Operand types</a></li>
</ul>
</li>
<li><a href="#mozTocId349731">7.2 Instructions</a></li>
<li><a href="#mozTocId531448"> 7.3 Other asm
instructions and directives</a>
<ul>
<li><a href="#mozTocId193996">7.3.1
Address spaces</a></li>
<li><a href="#mozTocId347216"> 7.3.2 Name
spaces</a></li>
<li><a href="#mozTocId659438"> 7.3.3
Scoped operands</a></li>
<li><a href="#mozTocId764040"> 7.3.4
Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mozTocId249962">Appendix A: Key codes</a></li>
</ul>
<br>
<h1><a class="mozTocH1" name="mozTocId65966"></a>
2. Basic things</h1>
<br>
Your task is to defend (or, perhaps, attack) a computer system,
represented on your display by a large rectangular arena. In this world
your will is executed by processes running on the system; processes can
move, sense their surroundings, attack, reproduce and many other
things. In some environments you can control them directly, while in
others they are free to make their own decisions.<br>
<br>
<h2><a class="mozTocH2" name="mozTocId768458"></a><span class="chapter"> 2.1 Types of programs</span></h2><br>The game recognises a few different kinds of programs:<br><ul><li>Processes, which are the things you see moving around on the screen and doing stuff.</li><li>An observer program, which provides a user interface.</li><li>One client program for each player. These supervise the players' processes.</li><li>Possibly, an operator program that lets the player give commands directly to their processes.</li><li>A system program, which is responsible for setting the rules and administering the game.</li></ul>There
are examples of each kind of program in the src subdirectory, with
prefixes indicating what kind they are (pr = process, op = operator, ob
= observer, sy = system, m = mission system). Files with the prsc
prefix use the standard command macros in the stand_coms.c file, which
means that they are designed to work with an operator. Files with just
the pr prefix are autonomous processes.<br><br>
The missions subdirectory contains the same&nbsp;source files as the
src subdirectory, but they are used for missions. It's probably best to
leave them alone and work in the src subdirectory.<br>
<h3><a class="mozTocH3" name="mozTocId912976"></a>
2.1.1 Processes</h3>
<br>
Each process is a small (&lt;=8KB) bytecode program running in a
16-bit virtual machine. The game comes with a number of pre-written
processes you can use, and you can write your own using the game's
built-in <a href="#Chapter:_Compiler">C compiler</a>
and <a href="#Chapter:_Bcode_and_the_assembler">assembler</a>.<br>
<br>
Processes use three resources:<br>
<ul>
<li>They are made out of <span style="text-decoration: underline;">data</span>, which
can be gathered with an
allocation method (a process with an allocation method is&nbsp;immobile). Different shapes and sizes of process cost different
amounts of data to create.</li>
</ul>
<ul>
<li>To perform actions using their methods they need <span style="text-decoration: underline;">interrupts</span>
(irpt), which can
be generated by an interrupt generation method.&nbsp;</li>
</ul>
<ul>
<li><span style="text-decoration: underline;">Instructions</span>
are consumed when a process performs basic computations
and are replenished each time the process runs (which is usually once
each
16 ticks, or about twice a second).<br>
</li>
</ul>
Each process has an <a href="#Chapter:_Interfaces">interface</a>
which allows it to interact with other
processes and the world around it. A process' interface gives it shape
and size and also sets out a range of <a href="#Chapter:_Methods">methods</a>
that the process can use.
Methods affect a process' characteristics or give it access to some
kind of special function. Some methods are external and can be seen on
the outside of the
process' interface, like the <a href="#Movement:_MT_PR_MOVE">Move
method</a> that allows a process to move
around, while others are internal, like the <a href="#Mathematics:_MT_PR_MATHS">Maths method</a> that
performs
various calculations.<br>
<br>
One way that processes can interact with each other is by generating
destructive data packets, and if a process absorbs too many of these it
will be explosively deallocated. Achieving your goals will probably
involve deallocating your opponents in this way, but exactly what your
objective is will depend on the nature of the computer system you are
trying to control.<br><br>
<h3><a class="mozTocH3" name="mozTocId420242"></a>2.1.2
System programs</h3>
<br>
The system is controlled by a system program, which is a bytecode
program running in the same kind of virtual machine as a process but
with a range of special privileges. A system program's interface
defines the
arena in which the conflict takes place, and a system program has
access to a special set of methods that give it control over basically
everything. System programs don't require data, but are subject to
(generous) limits on interrupts (3000 per tick) and instructions (30000
per tick).<br>
<br>
Among other things, a system program can spawn processes - and it is
this capability that an attacker must exploit.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId369045"></a>2.1.3
Observer programs</h3>
<br>
You will need some way to watch what's going on, and this is what an
observer program is for. It has access to methods that can read user
input from the mouse and keyboard, move the viewing screen's "camera"
around and present various forms of information to you. However, it
can't interact with processes directly.<br>
<br>
The system program may prevent the use of an observer program, as all
of an observer's functions can be performed by an operator program (see
below) or by the system itself.<br>
<br>
Like system programs, observers execute once per tick and have 3000
interrupts and 30000 instructions to play with.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId587352"></a>2.1.4
Client programs</h3>
<br>
Each player (including computer-controlled players) can have
its own client program, if the system allows it.
A client program serves as a kind of supervisor, keeping track of what
your processes are doing and issuing commands through a special command
method. Client programs
execute each tick and have the same interrupt and instruction limits as
system programs and observers.<br>
<br>
There are two kinds of client programs: operators and delegates. Which
kind you can use depends on the system program's settings.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId287138"></a>2.1.5
Client (operator)</h3>
<br>
An operator is a client program that also has access to the observer
methods that allow user input and exercise control over the user interface. Basically, an
operator lets you play the game directly, by turning mouse clicks and
keystrokes into commands issued to your processes.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId395479"></a>2.1.6
Client (delegate)</h3>
<br>
A delegate is just like an operator that can't use observer methods. It
can supervise your processes and coordinate their activities but it
can't read user input, so it has to be able to work autonomously.<br>
<br>
If the system allows you to use an operator, you can use a delegate
instead and waive the right to issue commands directly. If you do this,
you'll probably also want to load an observer (or you won't have much
of a user interface).<br>
<br>
<h2><a class="mozTocH2" name="mozTocId748685"></a>2.2
Templates</h2>
<br>
You can open the template menu by clicking on the little "Te" button
near the top right of the screen.<br>
<br>
To load any kind of program into the game, you need to put it into a
template. When the game first starts the only open template is for a
system program, but when you start playing you may be able to use
process, observer, delegate and operator templates as well (exactly
which types are available depends on the rules set by the system
program). Process templates can be used by the system program to
introduce processes into the world, and when one process creates
another process it can copy the new process' code from a process
template. The system program can also load observer, delegate and
operator programs from the respective templates.<br>
<br>
You can load a file directly from disk into a template using the "load
file" button on the template display. Two types of file are accepted:
compiled bcode (bytecode) files (with a .bc extension) and source files
(with a
.c extension). When you load a source file the code is compiled
automatically; if there is an error, the error message appears in the
message log at the bottom of the template window.<br>
<br>
You can also import a file from an open tab in the code editor using
the "import from editor" button.<br>
<br>
If you don't need a file in a template any more, you can clear the
template with the "clear" button.<br>
<br>
<h2><a class="mozTocH2" name="mozTocId683651"></a>2.3
Code editor</h2>
<br>
To open the code editor, click on the little "Ed" button near the top
right of the screen.<br>
<br>
The code editor is a basic&nbsp;integrated development environment&nbsp;for
the game's built-in compiler and assembler. You don't have to use it -
you can use another program entirely to edit your source files (I use
Code::Blocks), then use them by loading directly into templates - but
it has some&nbsp;features that can be useful, like test compilation and code completion for various keywords.<br>
<br>
The File, Edit and Find menus contain basic editor functions that do
obvious things. Note that editing or saving a file that is loaded into
a template will not change the version in the template, so you will
need to clear and
reload the template to update it.<br>
<br>
The Build menu gives you various tools for testing and analysing code
(although since loading a source file into a template
automatically invokes the compiler, you don't strictly need to use any
of them). The Build menu has the following functions:<br>
<dl style="font-weight: bold;">
<dt>Test build</dt>
</dl>
<dl>
<dd>This attempts to compile the currently open tab. If
successful, the results are discarded.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Build bcode</dt>
</dl>
<dl>
<dd>This attempts to compile the currently open tab, and if
successful it puts the result in a new bcode tab (although this may not
be very useful, as the editor can't do much with pure bcode).</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Build asm</dt>
</dl>
<dl>
<dd>This attempts to compile the currently open tab into
assembly language, and puts the result in a new tab.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Crunched asm</dt>
</dl>
<dl>
<dd>This does the same as Build asm, but tries to shorten
the generated asm code by fitting multiple instructions on each line
(because with one instruction per line, generated asm is often too long
for the editor).</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Convert bcode</dt>
</dl>
<dl>
<dd>If the currently open tab is a bcode tab, this converts
it into editable asm format. It will just be numbers, though (I may get
around to writing a disassembler at some point).</dd>
</dl>
<span style="font-weight: bold;">Import bcode</span>
<dl><dd>Use this during a game to import bcode from the currently
selected process (this is the process whose information is being
displayed in the process information box in the game display). The
process' current bcode state will be copied directly into a new bcode
tab.</dd></dl>
<br>
<span style="font-weight: bold;">Some limitations of the
editor:</span><br>
<ul>
<li>Source files can't be longer than 2000 lines;</li>
</ul>
<ul>
<li>Each line of a source file can't be longer than 160
characters.</li>
</ul>
These are also limitations of the compiler, which can't load files that
have too many lines (you can get around this with #include) and will have problems with files with lines that
are too long (you'll get a warning).<br>
<br>
<h2><a class="mozTocH2" name="mozTocId240196"></a><span style="font-weight: bold;">2.4 Menu interface</span></h2>
<br>
When you first start the game, you are in the start-up screen.<br>
<br>
The left side of the screen has a game menu with the following options:<br>
<br>
<span style="font-weight: bold;">Missions</span>
<dl style="font-weight: bold;">
</dl>
<dl>
<dd>Start playing a single-player mission.</dd>
</dl>
<dl style="font-weight: bold;"><li><span style="font-weight: bold;">Advanced missions</span></li></dl><dl><dd>Start playing an advanced single-player mission.<span style="font-weight: bold;"></span></dd></dl><dl style="font-weight: bold;"><dt><span style="font-weight: bold;">Tutorial</span>

</dt></dl><dl><dd>Start playing the tutorial. Try this first!</dd></dl>
<dl style="font-weight: bold;"><dt>Use System File</dt>
</dl>
<dl>
<dd>Start a game from a system file loaded into the
system file template (which is in the templates panel on the right-hand side of the screen).</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Load Saved Game</dt>
</dl>
<dl>
<dd>Load a saved game (*.sav) from disk.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Load Gamefile</dt>
</dl>
<dl>
<dd>Load a gamefile (*.gam) from disk. Used for multiplayer
games.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Exit</dt>
</dl>
<dl>
<dd>Exit.</dd>
</dl>
<br>
<br>
<span style="font-weight: bold;">Panel buttons</span><br>
<br>
A row of icons in the top right of the screen lets you switch what the
panel on the
right-hand side of the screen is used for:<br>
<dl style="font-weight: bold;">
<dt>Te (Templates)</dt>
</dl>
<dl>
<dd>Opens the template menu.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Ed (Editor)</dt>
</dl>
<dl>
<dd>Opens the code editor and compiler.</dd>
</dl>
<br>
When you are playing the game, three more buttons appear:<br>
<dl style="font-weight: bold;">
<dt>Pr (Programs)</dt>
</dl>
<dl>
<dd>Gives you information about the performance of the
system file and other programs.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Sy (System menu)</dt>
</dl>
<dl>
<dd>Opens a menu allowing you to start/stop the game,
save to disk etc.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>X (Close)</dt>
</dl>
<dl>
<dd>Closes the panel so you can see more of the game.</dd>
</dl>
<br>
<h1><a class="mozTocH1" name="mozTocId681248"></a>3.
Playing the game</h1>
<br>
There are two basic ways to begin playing the game: starting a mission,
and loading&nbsp;a system file.<br>
<br>
<h2><a class="mozTocH2" name="mozTocId784123"></a>
3.1 Missions</h2>
<br>
Missions are pre-set single-player games. Some of them are tutorials,
which you should probably play through before you try anything else.<br><br>When
you open the Missions menu, a number of default mission templates open
in the template panel. Programs loaded into these will be available at
the start of each mission you play until you exit the game. They start
preloaded with a basic operator, a factory and a&nbsp;defender process, but you can change these if you want to.<br><br>There
are also advanced missions: these are the same as the normal missions
but do not allow operator programs, so you will have to use a delegate
(or autonomous processes).<br>
<br>
<h2><a class="mozTocH2" name="mozTocId468133"></a>
3.2 Starting from a system file</h2>
<br>
To
use a system file, load it into the System File template (which is in
the Template panel&nbsp;to the right of the main menu), then click on
the Use System File
button in the main menu. This will open a setup menu which lets you set
the game's basic
parameters (unless the system program has made them unmodifiable).<br>
<br>
The setup menu works like this:<br>
<dl style="font-weight: bold;">
<dt>Start</dt>
</dl>
<dl>
<dd>Starts the game.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Players</dt>
</dl>
<dl>
<dd>This is the number of players, including any that are
computer-controlled. The game supports 2, 3 and 4 player games.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Turns</dt>
</dl>
<dl>
<dd>A
game can be set to last for 1 to 16 turns. If the system program allows
it, setting the number of turns to zero makes them unlimited (although
the system program can end the game and declare a winner at any time it wants).</dd>
</dl>
<dl>
<dd>Turns
may not be particularly important for a single-player game, but in a
multiplayer game the end of a turn is the time when players can update
their templates before sharing turnfiles.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Minutes per turn</dt>
</dl>
<dl>
<dd>A
turn can be anything from 1 to 60 minutes long. If the system program
lets you set the turn length to zero, turns will be indefinitely long
(the system program can end them, though).</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Processes</dt>
</dl>
<dl>
<dd>This is the maximum number of processes each player can
have at once (1 to 200).</dd>
</dl>
<dl style="font-weight: bold;">
<dt>World size (x/y)</dt>
</dl>
<dl>
<dd>This is the size of the world, in 128-pixel blocks (the
maximum width or height is 80 blocks, or about 10,000 pixels).</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Player names</dt>
</dl>
<dl>
<dd>You can change the player names, if you like.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Save gamefile</dt>
</dl>
<dl>
<dd>Gamefiles are used for multiplayer games (see below).</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Exit</dt>
</dl>
<dl>
<dd>Returns to the main menu.</dd>
<dt></dt>
</dl>
<h2><a class="mozTocH3" name="mozTocId690224"></a><span class="chapter">3.3 Multiplayer</span></h2>
<br>
Currently, play-by-email multiplayer with up to four players is
supported (simultaneous networked multiplayer may happen one day, but
not yet).<br>
<br>
A multiplayer game starts off with&nbsp;a system program designed
for multiplayer, which one
player or a neutral party uses to create a gamefile. Players take turns
by setting up their templates with code that gets turned into processes
in the game, and other code that supervises and directs those processes
(their delegate program). Each player makes a turnfile containing the
code in their templates, which they share with all the other players.
It's up to the players to work out how to best make use of their
templates! But the obvious ways to do so are to write new strategies
into delegate programs and update the structure and tactical code of
newly created processes (existing processes can't be reprogrammed
directly).<br>
<br>
Detailed instructions on how to set up and play a multiplayer game:<br>
<br>
<div style="margin-left: 40px;">1. One player (or a
neutral party) loads an appropriate system file into the system file
template
and clicks "Use System File" to enter the game setup menu.<br>
<br>
2. They use the setup menu to set up the game parameters (number of
players, player names, size of world etc.)
then&nbsp;use the "Save Gamefile" option in the setup
menu to save a gamefile, which they then send to all players by
attaching it to an email or something like that.<br>
<br>
3. Each player opens a copy of the gamefile using the "Load Gamefile"
button in the main menu.<br>
<br>
4. Each player takes their turn by loading program/process files into
their templates. At this stage players can test their
processes/programs as much as they want.<br>
<br>
5. Each player uses the "save turnfile" option at the top
of&nbsp;their section of the
template menu (this saves the contents of their templates to a .tf
file).<br>
<br>
6. Each player sends their turnfile to all other players.<br>
<br>
7. When everyone has everyone else's turnfiles, each player opens the
gamefile again and loads all of the players' turnfiles using the "load
turnfile" option in the players' sections of the template menu.<br>
<br>
8. Each player runs the game until the turn is over or someone wins.<br>
<br>
9. If a winner is declared, it's game over!<br>
<br>
10. Otherwise, go to step 4.<br>
</div>
<br>
<br>
Notes on multiplayer:<br>
<ul>
<li>The sy_multi.c program (in the src directory) is an
example of
a system program designed for multiplayer games.</li>
</ul>
<ul>
<li>Operator programs can't be used. If clients are permitted,
use delegate programs
instead.</li>
</ul>
<ul>
<li>Observer programs can be used, and can accept input. Each
player or
spectator can choose their own observer program, unless for some reason
the system program is designed not to allow this.</li>
</ul>
<ul>
<li>Players can save and load the game at any time. In
particular, they can
save after step 8 then load the game again when it's time to go back to
step 4 for the next turn. Saved games include templates, so you don't
need to reload the
gamefile or turnfiles after&nbsp;loading from a saved game.</li>
</ul>
<ul>
<li>While the game is running players shouldn't clear
or load any
templates, as this may cause desynchronisation. Only do this at step 4,
or during a test run that will be discarded.</li>
</ul>
<ul>
<li>The game verifies each turnfile for player number and turn
number when
loading.</li>
</ul>
<ul>
<li>There is no standard naming convention for turnfiles, other
than that
they should end in .tf, so players can agree on how to name them.</li>
</ul>
<ul>
<li>Multiplayer relies on each player's copy of the game being
the same
version and running in exactly the same way, except for observer
programs. The same version of the game should run the same way even
across different operating systems and build environments, as long as
they perform integer calculations in a consistent way (or at least
I think it should).</li>
</ul>
<ul>
<li>The system program shouldn't be designed to accept user
input or
communicate with
observer programs (unless you're sure you know what you're doing), as
this can cause desynchronisation.</li>
</ul>
<ul>
<li>If the players don't trust anyone in particular to set up
the gamefile
without altering the system program in a cheaty way, they can each
compile the system program on their own computer then make their own
gamefile. As long as the system program and all of the settings (world
size etc) are the same, the gamefiles should be identical.<br></li>
</ul>
<br>
<h1><a class="mozTocH1" name="mozTocId983713"></a><span class="chapter"><a name="Chapter:_Compiler"></a>4.
Compiler</span></h1>
<br>
Invincible Countermeasure is in essence a programming game.
One way to
program it is to write directly in bytecode, but you
probably don't want to do that. Instead, you can use its
special&nbsp;dialect of C!<br>
<br>
The game's built-in compiler is available from the code editor, and
is also automatically called when you load a source file into a
template. It is not a very good compiler. It has a range of limitations
and odd features, some dictated by the&nbsp;environment
but most resulting from the fact that I don't really know how to write
a compiler.<br>
<br>
(What I do know about how compilers work I
learned&nbsp;from&nbsp;Serge Zaitsev's CUCU
project (quote: "Never, please, never do it this way!"),
which&nbsp;is the only
explanation of basic compiler design that has made any sense at all to
me. See
<a href="http://zserge.com/blog/cucu-part1.html">http://zserge.com/blog/cucu-part1.html</a>.)<br>
<br>
The compiler also has an inline assembler. See the <a href="#Chapter:_Bcode_and_the_assembler">Assembler chapter</a>
below for details.<br>
<br>
Some of the compiler's "special" characteristics are:<br>
<ul>
<li>It has only one basic variable type: int, which is a 16-bit
signed
integer. No floats, chars, structs or unsigned variables. It
does allow arrays of ints, with up to three dimensions.</li>
</ul>
<ul>
<li>Pointers as a separate type are not supported. But memory
addresses are
just ints so you can, if you want, use the &amp; address-of
operator and the * dereference operator on ints to experience some of
the
excitement of using pointers. Also, *0 is valid (although not
very&nbsp;useful).</li>
</ul>
<ul>
<li>Referring to an array but leaving out a&nbsp;dimension
does not give a pointer
to the first element of that dimension. You have to use the &amp;
operator to get the address of the 0 element of the dimension. Sorry :(</li>
</ul>
<ul>
<li>It doesn't recognise statements used as
expressions. That
means no return a++;. You'll have to keep them separate, sorry :(</li>
</ul>
<ul>
<li>Variable scope is either global (to a process) or local (to
a
function). There is no block scope.</li>
</ul>
<ul>
<li>Operator precedence is non-standard. You can assume that
logical
operators bind more loosely than comparison operators, which bind more
loosely than arithmetic/bitwise operators, but other than that
everything is basically left-to-right. In particular, multiplication
doesn't bind more tightly than addition or subtraction. Use brackets!</li>
</ul>
<ul>
<li>It doesn't give many warnings. Also, some of its error
messages could
probably be a little more useful.</li>
</ul>
<ul>
<li>It doesn't do much optimisation. Actually, the only
optimisation it
does is basic constant folding (so it knows how to turn a = b + 5 + (2
* 2) into a = b + 9, although it's not smart enough to know how to fold
a = 5 + b + 4 because the constants aren't all in a row). On the bright
side the lack of optimisation leaves plenty of scope for fun with the
inline assembler.</li>
</ul>
<ul>
<li>Octal numbers aren't supported. I hope this will not cause
any great
inconvenience. Hexadecimal numbers are supported although I haven't got
around to updating the syntax highlighter to recognise them yet.</li>
</ul>
<ul>
<li>Binary numbers with the 0b prefix are supported (e.g. 0b11
is 3),
although the syntax highlighter doesn't know this either.</li>
</ul>
<ul>
<li>Programs need to be designed to be executed repeatedly.
This has
consequences for variable initialisation: static variables retain their
values between executions, so you may need&nbsp;special
initialisation code that you wouldn't usually need in a C program.</li>
</ul>
<ul>
<li>Currently, each source file must be no longer than 2,000
lines. If you
need a longer program you can use #include to combine multiple .c files
together. Also, each line must be no longer than 160 characters.</li>
</ul>
<ul>
<li>There are strict limits on compiled code size, although
this is really
a game constraint rather than a limitation of the compiler. System
programs must fit in 16384 words (each word is 16 bits), processes must
fit in 4096 and all other program types have 8192. This includes static
data and the stack, as well as any sub-processes.</li>
</ul>
<ul>
<li>There is no&nbsp;dynamic memory allocation (although I
guess you could implement it yourself if you really wanted to).</li>
</ul>
<ul>
<li>There is no linker. Everything that a program needs should
be in the
same .c file, or in other .c files that are #included directly.
</li>
</ul>
<ul>
<li>There are also no header files, and the .h extension isn't
supported.</li>
</ul>
<ul>
<li>None of the standard C libraries are available. Some things
that would
normally be done with libraries, like I/O routines and complicated
maths operations, are done using methods or special built-in functions.</li>
</ul>
<ul>
<li>Programs can contain other programs with their own special
address
space and naming scope. See processes and sub-processes.</li>
</ul>
<ul>
<li>Programs have a special "interface" definition at the
start, which
defines various characteristics of the program.</li>
</ul>
<br>
The&nbsp;programs in the src directory are full of
comments, so you could look at those if you're trying to work out how
to code in this environment.<br>
<br>
<h2><a class="mozTocH3" name="mozTocId381621"></a>4.1
Some C keywords that work differently</h2>
<span style="font-weight: bold;"><br>
static</span><br>
<br>
Declaring a variable as static should work as expected, except that it
will retain its value through repeated executions.<br>
<br>
Declaring a function as static means something different: it makes all
of the function's local variables, including function parameters,
static by default. The overhead involved in using automatic variables
makes it a good idea to always do this unless you are using recursion or something like that.<br>
<br>
<br>
<span style="font-weight: bold;">auto</span><br>
<br>
Currently, automatic arrays cannot be initialised with the syntax:<br>
<br>
<code><span class="excode">auto int hello [4] = {0,
1, 2, 3}; <span style="color: rgb(153, 153, 255);">// this does work for static arrays, though</span></span></code><br>
You will have to initialise each value separately:<br>
<br>
<code><span class="excode">auto int hello [4]; <span style="color: rgb(153, 153, 255);">// although since auto is
the default in an automatic function and can't be used in a static function, the auto keyword
is&nbsp;unnecessary</span><br>
hello [0] = 0;<br>
hello [1] = 1; <span style="color: rgb(153, 153, 255);">//
etc</span></span><span class="excode"></span></code>
<br>
Sorry.&nbsp;<br>
<br>
<br>
<span style="font-weight: bold;">main</span><br>
<br>
The main function's type is static void main(void).<br>
<br>
<br>
<span style="font-weight: bold;">switch</span><br>
<br>
Switch should work as expected, but the compiler always turns a switch
statement into a jump table. This is good where there are lots of cases
with not too much space between them, but not so good if there
are just a few cases or the cases have large gaps.<br>
<br>
<br>
<span style="font-weight: bold;">for</span><br>
<br>
Because statements and expressions aren't interchangeable, for
statements must always be in the form for (&lt;statement&gt;;
&lt;expression&gt;; &lt;statement&gt;).<br>
<br>
This shouldn't be a problem for basic uses like for (i = 0; i &lt;
10; i++) but may make some tricks difficult.<br>
<br>
<br>
<span style="font-weight: bold;">exit</span><br>
<br>
Since there's no stdlib, there's no exit function. I should really
write one. Until I do, you can exit by returning from main or by using the asm exit
instruction like this:<br>
<br>
<code><span class="excode">asm {exit}</span></code><br>
<br>
<span style="font-weight: bold;">Some other things that
are not supported:</span><br>
<br>
<code><span class="excode">variable types that are
not int</span><br class="excode">
<br class="excode">
<span class="excode">the ternary ? operator</span><br class="excode">
<br class="excode">
<span class="excode">const</span><br class="excode">
<br class="excode">
<span class="excode">typedef</span><br class="excode">
<br class="excode">
<span class="excode">sizeof</span><br class="excode">
<br class="excode">
<span class="excode">restrict</span><br class="excode">
<br class="excode">
<span class="excode">extern</span><br class="excode">
<br class="excode">
<span class="excode">register</span><br class="excode">
<br class="excode">
<span class="excode">volatile</span></code>
<br>
<br>
<h2><a class="mozTocH2" name="mozTocId408522"></a>
4.2 Processes and sub-processes</h2>
<br>
Processes that create other processes don't always have to copy their
code from templates - they can copy parts of themselves into other new
processes as well. This is what process definitions are for.<br>
<br>
A process definition looks like this:<br>
<br>
<span class="excode"></span><br class="excode">
<code><span class="excode">process i_am_a_process; <span style="color: rgb(153, 153, 255);">// this
declares/prototypes i_am_a_process as a process.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style="color: rgb(153, 153, 255);">// Put it at the
start along with function prototypes.</span><br>
process i_am_a_process <span style="color: rgb(153, 153, 255);">//
this is the definition of i_am_a_process</span><br>
{<br>
<span style="color: rgb(153, 153, 255);">// Process code
goes here.</span><br style="color: rgb(153, 153, 255);">
<span style="color: rgb(153, 153, 255);">// The process
should have an interface definition, a main function and anything </span><br style="color: rgb(153, 153, 255);">
<span style="color: rgb(153, 153, 255);">// else it will
need to be able to function independently.<br>
// You can use #include here to include another whole file as a
sub-process.<br></span>}<br>
</span><span class="excode"></span></code>&nbsp;<br>
In this example, i_am_a_process is a sub-process of the process in
which its definition appears, which we'll call the main process. This
means that the main process can use the code inside the process
definition to build new processes - see the details of the <a href="#New:_MT_PR_NEW">MT_PR_NEW
method</a> for how to do this. Some uses of sub-processes are:<br>
<ol>
</ol>
<ul>
<li>a "factory" process can build other processes using the
code inside a
process definition,</li>
</ul>
<ol>
</ol>
<ul>
<li>a core process can spawn new processes that connect to it and maybe also spawn their own nested sub-processes,
ending up
with a complex multisegmented super-process,</li>
</ul>
<ol>
</ol>
<ul>
<li>a system program can copy programs from sub-processes into
templates -&nbsp;the compiler uses the term "process", but
sub-processes can be
other types of program (client and observer) as well.</li>
</ul>
<ol>
</ol>
The code inside a process definition is not directly visible to the
main process, and cannot be executed directly by the main process (as
each process definition has its own address space which assumes that
the start of the process is address 0). However, a sub-process' bcode
can be modified at runtime. Compiled code can't do this without
horrible pointer arithmetic, but the assembler has a scope command that
can be used to modify sub-processes. Modifications will apply to any
processes newly created from the modified sub-process definition.<br>
<br>
The assembler has a corresponding type called an aspace (address
space). Each process definition also implicitly defines an aspace with
the same name for asm code to refer to.<br>
<br>
<h2><a class="mozTocH2" name="mozTocId883339"></a>4.3
Preprocessor</h2>
<br>
The preprocessor deals with both compiled and assembled code. It works
mostly like a standard C preprocessor, but with some differences.<br>
<br>
The following standard directives are supported:<br>
<br>
<code><span class="excode">#include</span><br class="excode">
<br class="excode">
<span class="excode">#define</span><br class="excode">
<br class="excode">
<span class="excode">#undef</span><br class="excode">
<br class="excode">
<span class="excode">#ifdef</span><br class="excode">
<br class="excode">
<span class="excode">#ifndef</span><br class="excode">
<br class="excode">
<span class="excode">#endif</span><br class="excode">
<br class="excode">
<span class="excode">#error</span></code>
<br>
The #define directive does not currently allow function-like macros.
A macro must be a single text string, and can't have parameters.<br>
<br>
The #error directive does not currently allow an error message to be
defined (so the directive is just #error). You will get a file name and
line number report, though.<br>
<br>
The
name of the file to be included by an #include directive should be
surrounded by quotes ("), and not angle brackets (&lt;&gt;).
The
path specified in the directive should be relative to the location of
the file in which the #include appears.<br>
<br>
One potential problem with using the #define directive is that a
#defined macro stays around for the rest of the preprocessing stage, or
until #undef'd. This will cause problems if you are using #include to
bring together multiple files and some of those files use the same
macros. To help deal with this, the special #subdefine directive
produces a
macro that is only visible within the file it appears in and any file
#included by that file.<br>
<br>
Also, these are not supported yet:<br>
<br>
<code><span class="excode">#if</span><br class="excode">
<br class="excode">
<span class="excode">#else</span><br class="excode">
<br class="excode">
<span class="excode">#elif</span><br class="excode">
<br class="excode">
<span class="excode">#line</span><br class="excode">
<br class="excode">
<span class="excode">#pragma</span></code>
<br>
<br>
<h2><a class="mozTocH2" name="mozTocId588312"></a>
4.4 Memory and registers</h2>
<br>
Each program consists of a certain number of 16-bit words of
memory: 4096
(processes), 8192 (observers/clients) or 16384 (system). This contains all of the program's code and data.<br>
<br>
The
first two addresses are taken up by a jump to the main function (or
wherever the programs starts), followed by the program's <a href="#Chapter:_Interfaces">interface
definition</a>, which is a few dozen words long (the exact length
depends
on the program type). In compiled code (but not necessarily assembled
code) the interface definition is followed by code, including any
sub-processes, then static data, then the stack. The stack grows
upwards from the end of the program.<br>
<br>
Programs have access to a few different sets of registers:<br>
<dl style="font-weight: bold;">
<dt>Processor registers</dt>
</dl>
<dl>
<dd>These
are the registers used for basic computation There are eight of them, A
to H, and you don't need to worry about them unless you're writing in
assembly language. Unlike the other kinds of registers, these are reset to zero each execution cycle.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Method registers</dt>
</dl>
<dl>
<dd>Each
program has a "bank" of 64 method registers, 4 for each method slot.
Method slot 1 can use method registers 0 to 3, method slot 2 can use 4
to 7 etc. Some methods take up more than one slot and can use 8, 12 or
16 method registers. Compiled code can address method registers using
the get, put and call built-in functions.</dd>
</dl>
<dl>
<dd>Method
registers have a few different purposes: they can determine what
happens when a method is called, they can contain useful information
about what the method is doing, and they can determine how a method
behaves between&nbsp;execution cycles. Exactly what each register
does
depends on the type of method it is associated with. The <a href="#Chapter:_Methods">method
descriptions</a> below have a full description of how each method
uses its
registers.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Command registers</dt>
</dl>
<dl>
<dd>Each
process has 16 command registers than can be read or written to by both
the process and the client program belonging to the same player
(allowing them to communicate with each other). The&nbsp;<a href="#Command_process:_MT_PR_COMMAND">MT_PR_COMMAND</a>, MR_PR_STD,
<a href="#Command_client:_MT_CL_COMMAND">MT_CL_COMMAND</a>
and MT_CLOB_STD methods can address these registers.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>System/observer shared registers</dt>
</dl>
<dl>
<dd>These
registers are shared by the system and observer (or operator). They
allow communication between these programs, similarly to the way the
command registers allow a client to communicate with its processes. The
<a href="#Control:_MT_OB_CONTROL">MT_OB_CONTROL</a>
and <a href="#Manage:_MT_SY_MANAGE">MT_SY_MANAGE</a>
methods can address these registers.</dd>
<dt></dt>
</dl>
<h2><a class="mozTocH2" name="mozTocId353779"></a>4.5
Built-in functions</h2>
<br>
The compiler has a number of built-in functions. Some of them give
access to basic features of the environment, while others facilitate
the use of methods so that you don't always
have to use the clunky put/get/call functions.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId831569"></a>4.5.1
Basic built-in functions</h3>
<br>
These are always available, and can be used by all program types.<br>
<br>
<br>
<span style="font-weight: bold;">put()</span><br>
<code><br>
int put(&lt;constant&gt; int method, &lt;constant&gt;
int method_register, int value ...)</code><br>
<br>
This sets a method register to a specified value. method, which must be
a constant, is the index of the method and should be a number from 0 to
15. method_register, which should also be a constant, is the index of
the register as an offset from the first register associated with the
method. value is the value that the register will be set to. If
multiple values are passed, they are put in successive registers.<br>
<br>
It returns 1 on success, 0 on failure.<br>
<br>
The MB_* number tokens are built-in macros that identify each method
register for each method type. See <a href="#Chapter:_Methods">Methods</a>&nbsp;for&nbsp;lists
of the
MB tokens for each method.<br>
<br>
Example:<br>
<br>
<code><span class="excode">put(METH_MOVE,
MB_PR_MOVE_RATE, 5,
16);</span></code><br>
This sets the first register (the RATE register) of the process' <a href="#Movement:_MT_PR_MOVE">move method</a> to 5
(this
affects the rate of movement), and the second register (which affects
how long the method will be activated for) to 16. It assumes that
METH_MOVE is an enum or macro that the user has defined to specify the
index of the move method.<br>
<br>
If either the method index or the method register index need to be
variables, you can't use put(). Use put_index() instead.<br>
<br>
<br>
<span style="font-weight: bold;">get()</span><br>
<br>
<code>int get(&lt;constant&gt; int method,
&lt;constant&gt;
int method_register);</code><br>
<br>
This is the opposite of put. It returns the value in a method register.<br>
<br>
Example:<br>
<br>
<code><span class="excode">a = get(METH_MOVE,
MB_PR_MOVE_RATE);</span></code><br>
<br>
<span style="font-weight: bold;">put_index()</span><br>
<br><code>
int put_index(int method_register, int value ...)</code><br>
<br>
This is like put(), but method_register is the target register's index
in the whole bank of method registers. Each process has 64 registers in
its method bank, and each method has 4 registers assigned to it (or 8,
12 or 16 if the method takes up multiple slots). Unlike in put(),
method_register can be a variable.<br>
<br>
Example:<br>
<br>
<code><span class="excode">put((METH_MOVE * 4) +
MB_PR_MOVE_RATE, 5, 16);</span></code><br>
This does the same thing as the example given for put() above.<br>
<br>
<br>
<span style="font-weight: bold;">get_index()</span><br>
<br>
<code>int get_index(int method_register)</code><br>
<br>
This is the get version of put_index().<br>
<br>
Example:<br>
<br>
<code><span class="excode">a = get((METH_MOVE * 4) +
MB_PR_MOVE_RATE);</span></code><br>
<br>
<span style="font-weight: bold;"><a name="built-in_function:_call"></a>call()</span><br>
<br>
<code>int call(int method, &lt;int value ...&gt;)</code><br>
<br>
This calls a method and returns the method's return value. method
should be the index of the method (0-15). What actually happens when a
method is called depends entirely on what kind of method it is; some
need to be called to do anything, while others don't need to be called
at all.<br>
<br>
If one or more values are also passed, they are put into the method's
registers (starting at register 0) before the call is executed. This
saves the need to write out a put statement before the call. Currently, you can&nbsp;only do this if method is a constant.<br>
<br>
Example:<br>
<br>
<code><span class="excode">a = call(METH_DESIGNATE,
MS_PR_DESIGNATE_LOCATE);</span></code><br>
This puts MS_PR_DESIGNATE_LOCATE into the first register of the
process'
designate method (MB_PR_DESIGNATE_STATUS), then calls the method and
leaves the method's return value in a. It assumes that METH_DESIGNATE
is an enum or macro that the user has defined to specify the index of
the <a href="#Designate:_MT_PR_DESIGNATE">designate method</a>.
MS_PR_DESIGNATE_LOCATE is a built-in method status
macro which tells the
DESIGNATE method to find its currently designated target.<br>
<br>
<br>
<span style="font-weight: bold;">process_start()</span><br>
<br>
<code>int process_start(process process_name)</code><br>
<br>
This returns the start address of a process (called process_name) that
is a sub-process of the current process. The sub-process must have been
declared previously.<br>
<br>
It doesn't work with sub-sub-processes (you can use asm for that if you
really want to).<br>
<br>
<br>
<span style="font-weight: bold;">process_end()</span><br>
<br>
<code>int process_end(process process_name)</code><br>
<br>
Just like process_start, but for the other end.<br>
<br>
<br>
<span style="font-weight: bold;">print()</span><br>
<br>
<code>void print(...)</code><br>
<br>
print sends a message to a console. By default, everything you print is
coloured light grey and goes to console 0. You can change this using the <a href="#Console:_MT_OB_CONSOLE">MT_OB_CONSOLE</a>
method.<br>
<br>
print accepts three kinds of parameters:<br>
<br>
1. String literals: <br>
<br>
<code><span class="excode">print("Hello!"); <span style="color: rgb(153, 153, 255);">// no C-style
formatted string input, sorry</span></span></code><br>
2. Expressions: <br>
<br>
<code><span class="excode">print(a + 5);</span></code><br>
3. Addresses of null-terminated strings: <br>
<br>
<code><span class="excode">print($&amp;string
[0]); <span style="color: rgb(153, 153, 255);">// the $
sign tells print to treat what follows as the address of the first
element of a string<br>
</span></span></code><br>
A single print statement can contain multiple kinds of things separated
by commas:<br>
<br>
<code><span class="excode">print("\nThe value is ",
value); <span style="color: rgb(153, 153, 255);">//
\n is newline</span></span></code><br>
or:<br>
<br>
<code><span class="excode">int name [10] =
{"Horatio"}; <span style="color: rgb(153, 153, 255);">//
note that
a string being declared must be surrounded by braces</span><br>
</span><span class="excode">print("\nHello! My name
is ", $&amp;name [0]);</span></code>
<br class="excode">
<br>
Fixing the horrible $&amp; syntax is on my to-do list.<br>
<br>
<br>
<span style="font-weight: bold;"><a name="built-in_functions:_data"></a>data(&lt;constant&gt;
int mode, &lt;various other constant
parameters&gt;)</span><br>
<br>
data is used to get various game constants that are known at compile
time, like the angle of each vertex in a particular shape. Unlike other
built-in functions it is resolved to a constant during compilation and
so
can be used anywhere a literal number could be used (e.g. in an
interface definition). Its parameters must be constants.<br>
<br>
The modes currently available are:<br>
<dl>
<dt>DATA_SHAPE_VERTICES</dt>
</dl>
<dl>
<dd>This gets the number of vertices a shape has.
Parameters: shape</dd>
</dl>
<dl>
<dt>DATA_SHAPE_VERTEX_ANGLE</dt>
</dl>
<dl>
<dd>The angle of a vertex from the process'
centre. Parameters: shape, vertex</dd>
</dl>
<dl>
<dt>DATA_SHAPE_VERTEX_DIST</dt>
</dl>
<dl>
<dd>The distance of a vertex from the process'
centre (in pixels). Parameters: shape, size, vertex</dd>
</dl>
<dl>
<dt>DATA_SHAPE_VERTEX_ANGLE_PREV</dt>
</dl>
<dl>
<dd>The angle from one vertex to the
previous one. Parameters: shape, vertex</dd>
</dl>
<dl>
<dt>DATA_SHAPE_VERTEX_ANGLE_NEXT</dt>
</dl>
<dl>
<dd>The angle from one vertex to the next
one. Parameters: shape, vertex</dd>
</dl>
<dl>
<dt>DATA_SHAPE_VERTEX_ANGLE_MIN</dt>
</dl>
<dl>
<dd>This
is the lowest angle offset that a directional method at this vertex can
have while still pointing outwards. For example, if a method at a
particular vertex can&nbsp;be pointed from between -2500 and 3000,
this
will return -2500. These angle offsets can be used in the angle field of
the interface definition for the method, and are also relevant to
methods that can change their angle (like <a href="#Directional_packet:_MT_PR_DPACKET">MT_PR_DPACKET</a>).</dd>
</dl>
<dl>
<dt>DATA_SHAPE_VERTEX_ANGLE_MAX</dt>
</dl>
<dl>
<dd>The same as DATA_SHAPE_VERTEX_ANGLE_MIN, but gets the
maximum angle offset.</dd>
</dl>
<br>
Examples:<br>
<br>
<code><span class="excode">a =
data(DATA_SHAPE_VERTICES, SHAPE_4SQUARE);<span style="color: rgb(153, 153, 255);"> // sets a to the number
of corners a square has. May not be so useful</span></span><br class="excode">
<span class="excode">vertex_angle =
data(DATA_SHAPE_VERTEX_ANGLE, SHAPE_6HEXAGON, 2); <span style="color: rgb(153, 153, 255);">//
sets vertex_angle to the angle of a hexagon's third vertex</span></span><br class="excode">
<span class="excode">vertex_dist =
data(DATA_SHAPE_VERTEX_DIST, SHAPE_3TRIANGLE, 1, 2); <span style="color: rgb(153, 153, 255);">//
sets vertex_dist to the distance from the centre of a triangular
process of size 1 to its&nbsp;vertex 2 (its third vertex)</span></span></code><br>
<br>
<h3><a class="mozTocH3" name="mozTocId917365"></a>4.5.2
Method-based built-in functions</h3>
<br>
These are built-in functions that facilitate the use of a particular
method. They only work in programs that include the appropriate method
in their interface.<br>
<br>
<br>
<span style="font-weight: bold;"><a name="built-in_functions:_MT_PR_INFO_method"></a>MT_PR_STD
method built-in functions</span><br>
<br>
The <a href="#Information:_MT_PR_INFO">MT_PR_STD method</a>
provides various standard functions, especially functions that give a process basic information about
itself and the rest of the world. These&nbsp;functions can only be used
by processes, and require there to be a MT_PR_STD method in the
process' interface. Most take no arguments and all return int.<br>
<br>
<dl>
<dt>int get_x(void)</dt>
</dl>
<dl>
<dd>Returns the process' x coordinate (in pixels, from
the left).</dd>
</dl>
<dl>
<dt>int get_y(void)</dt>
</dl>
<dl>
<dd>Returns the process' y coordinate (in pixels, from
the top).</dd>
</dl>
<dl>
<dt>int get_angle(void)</dt>
</dl>
<dl>
<dd>Returns the angle in which the process' vertex 0
is pointing, in integer degrees. Rightwards is angle 0, full circle is
8192.</dd>
</dl>
<dl>
<dt>int get_speed_x(void)</dt>
</dl>
<dl>
<dd>Returns&nbsp;the x component of the process'
velocity, in pixels per tick multiplied by 16 (because without
multiplication it would often be too small). Can be positive
(rightwards) or negative (leftwards).</dd>
</dl>
int get_speed_y(void)
<dl>
<dd>Returns&nbsp;y speed. Positive is down, negative is
up.</dd>
</dl>
int get_team(void)
<dl>
<dd>Returns&nbsp;the team (player index) that the process
belongs to. Player 1 is 0, player 2 is 1 etc.</dd>
</dl>
int get_hp(void)
<dl>
<dd>Returns&nbsp;how many hit points the process has.</dd>
</dl>
int get_hp_max(void)
<dl>
<dd>Returns&nbsp;the maximum hp the process can have.</dd>
</dl>
int get_instr(void)
<dl>
<dd>Returns&nbsp;how many instructions the process has
left to execute this tick. Imprecise, as the function itself costs
instructions.</dd>
</dl>
int get_instr_max(void)
<dl>
<dd>Returns&nbsp;how many instructions it started with.</dd>
</dl>
int get_irpt(void)
<dl>
<dd>Returns&nbsp;how many interrupts the process has left. If the process is connected to other processes, this is the shared total.</dd>
</dl>
int get_irpt_max(void)
<dl>
<dd>Returns&nbsp;the process' maximum number of
interrupts. If the process is connected to other processes, this returns the shared total maximum.</dd></dl>
int get_own_irpt_max(void)
<dl><dd>Returns&nbsp;the process' maximum number of
interrupts. Is not affected by connected processes.</dd>
</dl>
int get_data(void)
<dl>
<dd>Returns&nbsp;how much data the process has left. If the process is connected to other processes, this is the shared total.</dd>
</dl>
int get_data_max(void)
<dl>
<dd>Returns&nbsp;how much data it can store. If the process is connected to other processes, this returns the shared total maximum.</dd>
</dl>
int get_own_data_max(void)
<dl><dd>Returns&nbsp;how much data it can store.&nbsp;Is not affected by connected processes.<br></dd></dl>int get_spin(void)
<dl>
<dd>Returns&nbsp;an approximation of the process' rotation
speed, in integer angle units per tick (8192 is a full circle). Can be
positive (clockwise) or negative (anticlockwise).</dd>
</dl>
int get_group_x(void)
<dl>
<dd>If the process is a member of a group of
processes joined together by <a href="#Link:_MT_PR_LINK">MT_PR_LINK
methods</a>, this returns the x
coordinate of the centre of the group (which is roughly the group's centre of mass). If the process is not a member
of a group, this just returns the process' x coordinate.</dd>
</dl>
int get_group_y(void)
<dl>
<dd>Similar.</dd>
</dl>
int get_group_x_speed(void)
<dl>
<dd>If the process is a member of a group,
returns the x component of the group's velocity (measured at the
group's centre of mass).</dd>
</dl>
int get_group_y_speed(void)
<dl>
<dd>The same, for y.</dd>
</dl>
int get_group_members(void)
<dl>
<dd>Returns&nbsp;the number of processes in the
process' group, including the process itself. Returns 1 if the process
is not a member of a group.</dd>
</dl>
int get_world_x(void)
<dl>
<dd>Returns&nbsp;the width of the game arena, in pixels.</dd>
</dl>
int get_world_y(void)
<dl>
<dd>Same, for height.</dd>
</dl>
int get_ex_time(void)
<dl>
<dd>Returns the number of ticks until the process
executes again (this isn't very useful for a process, but a client may
have a use for the query version of this).</dd>
</dl>
int get_efficiency(void)
<dl>
<dd>Returns the efficiency that an allocator
process would have at the process' location. This is a more expensive
operation, and costs 32 irpt.</dd></dl>
int get_vertices(void)
<br><dl><dd>Returns the number of vertices the process has. Like
data(DATA_SHAPE_VERTICES, &lt;shape&gt;),&nbsp;but since this is a
method call it is not fixed at compile time. May be useful if the
process' shape can be changed by the process that creates it.</dd></dl><dl>
</dl>
<dl><dt>int get_vertex_angle(int vertex)</dt></dl><dl><dd>Returns the angle of one of the process'&nbsp;vertices.</dd></dl><dl><dt>int get_vertex_dist(int vertex)</dt></dl><dl><dd>Returns the distance (in pixels) from the centre of the process to one of its vertices.</dd></dl><dl><dt>int get_vertex_angle_next(int vertex)</dt></dl><dl><dd>The angle from one vertex to the next
one.</dd></dl><dl><dt>int get_vertex_angle_prev(int vertex)</dt></dl><dl><dd>The angle from one vertex to the previous
one.</dd></dl><dl><dt>int get_vertex_angle_min(int vertex)</dt></dl><dl><dd>The minimum offset from zero that a method at a particular vertex can have.</dd></dl><dl><dt>int get_vertex_angle_max(int vertex)</dt></dl><dl><dd>The maximum offset from zero that a method at a particular vertex can have.</dd></dl><dl><dt>get_method(int method_index)</dt></dl><dl><dd>Returns the type (MT_PR_?) of method method_index.</dd></dl><dl><dt>get_method_find(int method_type, int number)</dt></dl><dl><dd>Returns
the index of the first method of method_type in the process' interface,
if number is 0. If number is 1, returns the second instance of that
method type. If 2, the third (etc). </dd></dl><dl><dt>set_command(int command_register, int value)</dt></dl><dl><dd>Sets
one of the process'&nbsp;command registers to&nbsp;value. Note that
reading command registers requires the separate MT_PR_COMMAND method.</dd></dl><dl><dt>set_command_bit_1(int command_register, int bit)</dt></dl><dl><dd>Sets a bit of the value in&nbsp;command_register to 1. For example:<br></dd></dl><code><span class="excode">set_command_bit_1(3, 5);&nbsp;<span style="color: rgb(153, 153, 255);">// sets bit 5 of register 3 to 1</span></span><br class="excode">
<span class="excode"></span></code><br><dl><dt>set_command_bit_0(int command_register, int bit)</dt></dl><dl><dd>Sets a bit of the value in&nbsp;command_register to 0.</dd></dl><br>
<br>
<span style="font-weight: bold;"><a name="built-in_functions:_MT_PR_COMMAND"></a>MT_PR_COMMAND
(process command) built-in functions</span><br>
<br>
A process can use the <a href="#Command_process:_MT_PR_COMMAND">MT_PR_COMMAND
method</a> to read from its 16
command registers, which let it communicate with a client or operator
program (writing to its command registers just requires the MT_PR_STD method). The built-in functions are:<br>
<br>
<dl>
<dt>int get_command(int command_register)</dt>
</dl>
<dl>
<dd>This returns the contents of a command register (0-15).
</dd>
</dl>
<dl>
<dt>int get_command_bit(int command_register, int bit)</dt>
</dl>
<dl>
<dd>This gets a single bit from a command register. For example:</dd><dt><code><span class="excode"></span></code></dt><dt><code><span class="excode">a = get_command_bit(3, 5);&nbsp;<span style="color: rgb(153, 153, 255);">// returns 1 if bit 5 of register 3 is 1, and 0 otherwise</span></span></code></dt>
</dl>
<br>
<span style="font-weight: bold;"><a name="built-in_functions:_MT_CL_COMMAND_GIVE"></a>MT_CL_COMMAND_GIVE
(client command-give) built-in functions</span><br>
<dl>
<dt>A client can use the <a href="#Command_client:_MT_CL_COMMAND">MT_CL_COMMAND_GIVE method</a>
to&nbsp;write to the command registers of its processes.</dt>
</dl>
int command(int process_index, int command_register, int
value)<dl>
</dl>
<dl>
<dd>This sets a specified command register belonging to a
specified process
to a specified value. It takes only one value at a time.</dd>
</dl>int command_bit_1(int process_index, int command_register, int bit)
<dl><dd>This sets a specified bit of a specified command register belonging to a
specified process
to 1.<span style="font-weight: bold;"></span><br></dd></dl>int command_bit_0(int process_index, int command_register, int bit)
<dl><dd>This sets a specified bit of a specified command register belonging to a
specified process
to 0.<span style="font-weight: bold;"></span><br></dd></dl><span style="font-weight: bold;"></span><span style="font-weight: bold;"><br><a name="built-in_functions:_MT_CLOB_COMMAND_REC"></a>MT_CLOB_COMMAND_REC
(client/observer command-receive) built-in functions</span><br>
<dl><dt>A client or observer can use the <a href="Manual.html#Command_client:_MT_CL_COMMAND">MT_CLOB_COMMAND_REC method</a>
to read&nbsp;the command registers of&nbsp;processes.</dt><dt></dt><dt>int check_command(int process_index, int command_register)</dt></dl>
<dl><dd>This returns the contents of a specified command register
belonging to
a specified process. The process must belong to the same player as the
client program (or any player if the method is being used by a system
or observer
program).</dd></dl>int check_command_bit(int process_index, int command_register, int bit)
<dl><dd>This returns the contents of a specified bit of a specified command register
belonging to
a specified process. The process must belong to the same player as the
client program (or any player if the method is being used by a system or observer
program).</dd></dl>
<br>
<span style="font-weight: bold;"><a name="built-in_functions:_MT_CLOB_QUERY"></a>MT_CLOB_QUERY
(query) built-in functions</span><br>
<br>
The <a href="#Query:_MT_CLOB_QUERY">MT_CLOB_QUERY method</a>
is like the INFO method, but it is used by client or
observer methods to get information about processes. Most of the
get_*() built-in INFO functions have corresponding query functions
which are used in the same way, except that the query function takes a
process index as an argument. The process does not have to be
controlled by the same player as the client/observer program.<br>
<br>
Example:<br>
<br>
<code><span class="excode">a =
query_x(process_index);</span></code><br>
This sets a to the x coordinate of the process with the index
process_index.<br>
<br>
Unlike get_* functions, query functions can be called against
non-existent processes. If the specified process does not exist, a
query function will usually return -1. However, if a process is
destroyed its index will be reserved for several ticks afterwards,
during which time it is being de-allocated and its index will not be
re-used, and a query will return -2 instead. Calling a query function
that should not otherwise return a negative number (e.g. query_hp(...))
allows a client/observer process to check whether a process exists.<br>
<br>
Some of the get functions do things that client processes can do better
with other methods, so there are no built-in query functions for these
(although call can be used instead if for some reason you want to).
These are get_world_x(), get_world_y() and get_efficiency().<br><br>One
query function that doesn't have a get equivalent is query_mbank(int
process_index, int method_register), which returns the value of a
method register of a process (and is equivalent to the process calling
get_index()).<br>
<br>
<br>
<span style="font-weight: bold;"><a name="built-in_functions:_MTYPE_CLOB_WORLD"></a>MTYPE_CLOB_WORLD
(world information) built-in functions</span><br>
<br>
The <a href="#World:_MT_CLOB_WORLD">MTYPE_CLOB_WORLD
method</a> gives a client/observer/system program
information about the parameters of the game.<br>
<dl>
<dt>int world_x(void)</dt>
</dl>
<dl>
<dd>Returns the width of the game area (in pixels).</dd>
</dl>
<dl>
<dt>int world_y(void)</dt>
</dl>
<dl>
<dd>Same, for height.</dd>
</dl>
<dl>
<dt>int world_processes(void)</dt>
</dl>
<dl>
<dd>Returns the maximum number of processes
that can exist in the world.</dd>
</dl>
<dl>
<dt>int world_processes_each(void)</dt>
</dl>
<dl>
<dd>Returns the maximum number of
processes that each player can have at once.</dd>
</dl>
<dl>
<dt>int world_team(void)</dt>
</dl>
<dl>
<dd>For a client program, returns the program's
player index. Returns -1 for observer and system programs.</dd>
</dl>
<dl>
<dt>int world_teams(void)</dt>
</dl>
<dl>
<dd>Returns the number of players.</dd>
</dl>
<dl>
<dt>int world_first_process(void)</dt>
</dl>
<dl>
<dd>For a client program, returns the
lowest index that a process controlled by this player can have (so
player 1 might control indices 0-99 while player 2 controls 100-199 and
player 3 controls 200-299). Produces undefined results for other
program types (they can call the method directly with a parameter to
find out this value for particular players).</dd>
</dl>
<dl>
<dt>int world_last_process(void)</dt>
</dl>
<dl>
<dd>Like world_first_process(), but returns
the highest process index.</dd>
</dl><dl><dt>int world_time(void)</dt></dl><dl><dd>Returns the number of ticks elapsed so
far. This overflows easily, so after&nbsp;the program's WORLD method is
called in this way,&nbsp;register 1 of the method holds the number of
ticks divided by 32,767.</dd></dl>
<br>
<span style="font-weight: bold;"><a name="built-in_functions:_Maths"></a>MT_PR_MATHS/MT_CLOB_MATHS
(mathematics) built-in functions</span><br>
<br>
These all require either the <a href="#Mathematics:_MT_PR_MATHS">MT_PR_MATHS</a>
or the <a href="#Maths_clob:_MT_CLOB_MATHS">MT_CLOB_MATHS</a>
method.<br>
<br>
Because only integers are available, the trigonometric functions use an
integer angle system in which 0 is directly right and 8192 is a full
circle clockwise (so 2048 is down, 4096 is left and 6144 is up). Angles
less than 0 or greater than 8191 just wrap around, so you don't need to
bounds-check angle values. There are a number of built-in macros for
angles: ANGLE_1 is a full circle (8192), ANGLE_2 is a half circle
(4096) etc all the way to ANGLE_32.<br>
<br>
A limitation of the maths functions is that they cannot be used as
parameters of each other or themselves (this is because they are simple
wrappers around the call function, and trying to call the maths method
like this causes its registers to be overwritten with each call). So,
for example, you can't do this:<br>
<br>
<code class="excode">a = angle_difference(1000, atan2(y,
x)); <span style="color: rgb(153, 153, 255);">// the call
to atan2
overwrites values needed for the angle_difference call before it can be
executed</span></code><br>
Use variables to store the intermediate steps instead (this is actually
a limitation of all method-based built-in functions, but it's most
significant for the maths ones).<br>
<dl>
<dt>int hypot(int y, int x)</dt>
</dl>
<dl>
<dd>Returns the hypotenuse of y and x. Useful for
distance calculations.</dd>
</dl>
<dl>
<dt>int sqrt(int value)</dt>
</dl>
<dl>
<dd>Returns&nbsp;the square root of value. Returns 0 if
value &lt;= 0.</dd>
</dl>
<dl>
<dt>int pow(int value1, int value2)</dt>
</dl>
<dl>
<dd>Returns&nbsp;value1 to the power of value2.</dd>
</dl>
<dl>
<dt>int abs(int value)</dt>
</dl>
<dl>
<dd>Returns&nbsp;the magnitude of value.</dd>
</dl>
<dl>
<dt>int angle_difference(int angle1, int angle2)</dt>
</dl>
<dl>
<dd>Returns&nbsp;the magnitude of
the shortest distance (in integer degrees) between angle1 and angle2.
Takes account of wrapping, so if you call, for example,
angle_difference(8000, 100) it will correctly return 292 instead of
7900.</dd>
</dl>
<dl>
<dt>int signed_angle_difference(int angle1, int angle2)</dt>
</dl>
<dl>
<dd>Like
angle_difference(), but returns a signed value (calculated from angle1)
instead of a magnitude (so, for example, signed_angle_difference(300,
100) returns -200).</dd>
</dl>
<dl>
<dt>int turn_direction(int angle1, int angle2)</dt>
</dl>
<dl>
<dd>Returns&nbsp;the direction of
the closest way from angle1 to angle2: returns 1 for clockwise, -1 for
anticlockwise and 0 if the angles are same (for example,
turn_direction(5000, 3000) returns -1).</dd>
</dl>
<dl>
<dt>int sin(int angle, int value)</dt>
</dl>
<dl>
<dd>Returns&nbsp;the sine of angle (which should
be in integer degrees) multiplied by value. Its most obvious use is to
determine the y component of a line that has angle (angle) and is
(value) pixels long.</dd>
</dl>
<dl>
<dt>int cos(int angle, int value)</dt>
</dl>
<dl>
<dd>Returns&nbsp;a cosine multiplied by value.
Use this to determine the x component of a line.</dd>
</dl>
<dl>
<dt>int atan2(int y, int x)</dt>
</dl>
<dl>
<dd>Returns&nbsp;an arctangent, in integer degrees
(equivalent to C's atan2 function). This function is useful for getting
the angle of a line joining two points, but it is relatively expensive.<br>
</dd>
</dl>
<span style="font-weight: bold;"></span><br>
<h1><a class="mozTocH1" name="mozTocId282111"></a><a name="Chapter:_Interfaces"></a> 5. Interfaces</h1>
<br>
Each program must have an interface definition, which sets out what
methods it has available to it. For processes, the interface definition
also determines the shape and size of the process. For system programs,
the interface definition sets the basic parameters of the game.<br>
<br>
<h2><a class="mozTocH3" name="mozTocId530141"></a>
5.1 Process interface</h2>
<br>
Process interface definitions are in the following format:<br>
<br>
<br class="excode">
<span class="excode"><code>interface<br>
{<br>
&nbsp;(program type), <br>
&nbsp;(process shape), <br>
&nbsp;(process size), <br>
&nbsp;(base vertex),<br>
&nbsp;{<br>
&nbsp; &nbsp;{<br>
&nbsp; &nbsp; (method type),<br>
&nbsp; &nbsp; (method vertex),<br>
&nbsp; &nbsp; (method angle),<br>
&nbsp; &nbsp; (method extension 0), <br>
&nbsp; &nbsp; (method extension 1),<br>
&nbsp; &nbsp; (method extension 2)<br>
&nbsp; &nbsp;},<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; (method type),<br>
&nbsp;&nbsp;&nbsp; (method vertex),<br>
&nbsp;&nbsp;&nbsp; (method angle),<br>
&nbsp;&nbsp;&nbsp; (method extension 0),<br>
&nbsp;&nbsp;&nbsp; (method extension 1),<br>
&nbsp;&nbsp;&nbsp; (method extension 2)<br>
&nbsp;&nbsp; },<br>
&nbsp; &nbsp;{<br>
&nbsp; &nbsp;&nbsp;etc... (up to 16 methods)<br>
&nbsp; &nbsp;}<br>
&nbsp;}<br>
}</code><br>
</span><span class="excode"></span><br class="excode">
<br>
<span style="font-weight: bold;">Program type</span><br>
<dl>
<dd>For a process, the program type must be
PROGRAM_TYPE_PROCESS. Other types are:</dd>
</dl>
<dl>
<dd>PROGRAM_TYPE_DELEGATE</dd>
<dd>PROGRAM_TYPE_OPERATOR</dd>
<dd>PROGRAM_TYPE_OBSERVER</dd>
<dd>PROGRAM_TYPE_SYSTEM</dd>
</dl>
<span style="font-weight: bold;">Process shape</span><br>
<dl>
<dd>This is the shape (octagon, pointy hexagon, diamond etc)
that embodies the process. See <a href="#Shapes">process
shapes/sizes</a>.</dd>
</dl>
<span style="font-weight: bold;">Process size</span><br>
<dl>
<dd>From 0 to 3. The size of a process determines how durable
it is, how much it costs to build, how much irpt and data it can fit in
its buffers and how much method mass it can have. See <a href="#Shapes">process
shapes/sizes</a>.</dd>
</dl>
<span style="font-weight: bold;">Base vertex</span><br>
<dl>
<dd>The is the default vertex that will be directly
next to the parent process, if the parent process' <a href="#New:_MT_PR_NEW">NEW method</a> specifies
the child vertex as -1.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Methods</dt>
</dl>
<dl>
<dd>A process can have up to 16 of these, as long it has enough
capacity for their mass.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Method type</dt>
</dl>
<dl>
<dd>One of the <a href="#Process_methods_PR">MT_PR_*
values</a>. MT_PR_NONE (0) means no method.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Method vertex</dt>
</dl>
<dl>
<dd>If
the method is an external method, this is the vertex it will be
installed into. Only one method can be at each vertex. This value
doesn't matter for internal methods.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Method angle</dt>
</dl>
<dl>
<dd>If
the method is a directional external method, this is an offset to the
angle it points in. 0 means the method will point directly away from
the centre of the process, -ANGLE_4 will point 90 degrees anticlockwise
from that, etc.&nbsp;</dd>
<dd></dd>
<dd>Methods can't point inwards. If
you try to set a method pointing inwards, its angle will be corrected
to the nearest valid angle.&nbsp;</dd>
<dd></dd>
<dd>If you want to set
an angle with reference to the whole process' angle (for example, you
want to point a <a href="#Movement:_MT_PR_MOVE">MOVE
method</a> directly backwards) you can set the angle
value to the angle you want the method to point in relative to the
process' angle, minus the angle of the vertex. See the MOVE methods in
the example just below.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Extensions</dt>
</dl>
<dl>
<dd>Some methods can be optimised in various ways by giving
them extensions. See Extensions.</dd>
<dd></dd>
<dd>A method can have at most 4 total levels of extensions.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Error methods</dt>
</dl>
<dl>
<dd>If
there's something wrong with a method in an interface definition, it
might be replaced by an error method that indicates what went wrong
(for example, you tried to put two methods on a single vertex). See <a href="#Special_methods">special methods</a>.</dd>
</dl><dl style="font-weight: bold;"><dt>Method enums</dt></dl>
<dl><dd>If you put a label in front of a method definition, it will be
turned into an enum with a value equal to the index of that method
(even if there are gaps). Thanks to Peter Hull for coding this!</dd></dl>
Example of a process interface:<br>
<br>
<code><span class="excode">interface<br>
{<br>
&nbsp;PROGRAM_TYPE_PROCESS, SHAPE_4POINTY, 3, 3,<span style="color: rgb(153, 153, 255);"> // program type, shape,
size (from 0-3), base_vertex</span><br>
&nbsp;{<br>
&nbsp; METH_MOVE1: {MT_PR_MOVE, 1, ANGLE_2 - data(DATA_SHAPE_VERTEX_ANGLE,
SHAPE_4POINTY, 1)}, <span style="color: rgb(153, 153, 255);">//
acceleration method on vertex 1, pointing 180deg (ANGLE_2) relative to
vertex 0</span><br>
&nbsp; METH_MOVE2: {MT_PR_MOVE, 3, ANGLE_2 - data(DATA_SHAPE_VERTEX_ANGLE,
SHAPE_4POINTY, 3)}, <span style="color: rgb(153, 153, 255);">//
acceleration method on vertex 3, pointing 180deg (ANGLE_2) relative to
vertex 0</span><br>
&nbsp; METH_COM: {MT_PR_COMMAND}, <span style="color: rgb(153, 153, 255);">//
command method. allows process to communicate with operator/delegate</span><br>
&nbsp; METH_MATHS: {MT_PR_MATHS}, <span style="color: rgb(153, 153, 255);">//
maths method. allows trigonometry etc.</span><br>
&nbsp; METH_STD: {MT_PR_STD}, <span style="color: rgb(153, 153, 255);">// standard process method. does several basic things like giving&nbsp; access to process's current properties
(location etc)</span><br>
&nbsp; {MT_PR_IRPT}, <span style="color: rgb(153, 153, 255);">//
generates irpt. functions automatically (although can be configured not
to)</span><br>
&nbsp; METH_PACKET: {MT_PR_PACKET, 0, 0, 1, 1, 1}, <span style="color: rgb(153, 153, 255);">// packet method. allows
process to attack.</span><br>
&nbsp; METH_SCAN: {MT_PR_SCAN}, <span style="color: rgb(153, 153, 255);">//
scan method. allows process to sense its surroundings. takes up 3
method slots</span><br>
&nbsp; {MT_NONE}, <span style="color: rgb(153, 153, 255);">//
space for scan method</span><br>
&nbsp; {MT_NONE}, <span style="color: rgb(153, 153, 255);">//
space for scan method</span><br>
&nbsp; METH_DESIGNATE: {MT_PR_DESIGNATE}, <span style="color: rgb(153, 153, 255);">// designator. allows
process to keep track of a target acquired through scan</span><br>
&nbsp;}<br>
}</span></code><span class="excode"></span><br>
<br>
<h2><a class="mozTocH3" name="mozTocId636847"></a>5.2
Client/observer program interface</h2>
<br>
These are&nbsp;like
process interfaces, except that they do not specify a shape, size or
base vertex. Since no client/observer methods are external or have
extensions, these kinds of interfaces can be a bit simpler. <br>
<br>
For example, this is an interface for an operator program:<br>
<br>
<code><span class="excode">interface<br>
{<br>
&nbsp;PROGRAM_TYPE_OPERATOR, <span style="color: rgb(153, 153, 255);">// program's type</span><br>
&nbsp;{<br>
&nbsp; {MT_OB_INPUT}, <span style="color: rgb(153, 153, 255);">//
input method - allows reading of user input</span><br>
&nbsp; {MT_CL_COMMAND}, <span style="color: rgb(153, 153, 255);">//
command method - allows operator to communicate with processes</span><br>
&nbsp; {MT_CLOB_POINT}, <span style="color: rgb(153, 153, 255);">//
point check - allows operator to find what is at a particular point</span><br>
&nbsp; {MT_OB_VIEW}, <span style="color: rgb(153, 153, 255);">//
view - allows interaction with display</span><br>
&nbsp; {MT_NONE}, <span style="color: rgb(153, 153, 255);">//
makes space for view method</span><br>
&nbsp; {MT_OB_SELECT}, <span style="color: rgb(153, 153, 255);">//
select - allows operator to set display elements indicating selected
process</span><br>
&nbsp; {MT_OB_CONSOLE}, <span style="color: rgb(153, 153, 255);">//
console - allows operator to control console windows</span><br>
&nbsp; {MT_CLOB_WORLD}, <span style="color: rgb(153, 153, 255);">//
world - gives information about the game world</span><br>
&nbsp; {MT_CLOB_QUERY}, <span style="color: rgb(153, 153, 255);">//
query - allows operator to get information about processes (similar to
MT_PR_INFO)</span><br>
&nbsp; {MT_CLOB_MATHS}, <span style="color: rgb(153, 153, 255);">//
maths method (works the same way as MT_PR_MATHS)</span><br>
&nbsp; {MT_CLOB_SCAN}, <span style="color: rgb(153, 153, 255);">//
scanner - similar to MT_PR_SCAN but with some additional features</span><br>
&nbsp; {MT_NONE}, <span style="color: rgb(153, 153, 255);">//
makes space for scan method</span><br>
&nbsp; {MT_NONE}, <span style="color: rgb(153, 153, 255);">//
makes space for scan method</span><br>
&nbsp; {MT_OB_CONTROL}, <span style="color: rgb(153, 153, 255);">//
control - allows operator to query various things about the user
interface</span><br>
&nbsp;}<br>
}</span></code><br>
<br>
<h2><a class="mozTocH3" name="mozTocId951354"></a>5.3
System program interface</h2>
<br>
System program interfaces are a bit more complicated, because they need
to set out some of the game rules right at the start.<br>
<br>
<code><span class="excode">interface<br>
{<br>
&nbsp;(program type),<br>
&nbsp;{Options: number of players},<br>
&nbsp;{Options: number of turns},<br>
&nbsp;{Options: length of each turn,&nbsp;in minutes},<br>
&nbsp;{Options: number of processes each player can have},<br>
&nbsp;{Options: number of packets each player can have},<br>
&nbsp;{Options: width of game area, in 128-pixel blocks},<br>
&nbsp;{Options: height of game area},<br>
&nbsp;(allow player clients),<br>
&nbsp;(player number of operator),<br>
&nbsp;(allow user observer),<br>
&nbsp;{(whether player 0 may change its client template), (whether
player 1 may do so), etc.},<br>
&nbsp;{(whether player 0 may change its process templates),
(whether player 2 may do so), etc.},<br>
&nbsp;{<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; (method type), <span style="color: rgb(153, 153, 255);">// this is the only field
that is actually used</span><br>
&nbsp;&nbsp;&nbsp; (method vertex), <span style="color: rgb(153, 153, 255);">// vertex, angle and
extension are only relevant to processes</span><br>
&nbsp;&nbsp;&nbsp; (method angle),<br>
&nbsp;&nbsp;&nbsp; (method extension 0),<br>
&nbsp;&nbsp;&nbsp; (method extension 1),<br>
&nbsp;&nbsp;&nbsp; (method extension 2)<br>
&nbsp;&nbsp; },<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; (method type),<br>
&nbsp;&nbsp;&nbsp; (method vertex),<br>
&nbsp;&nbsp;&nbsp; (method angle),<br>
&nbsp;&nbsp;&nbsp; (method extension 0),<br>
&nbsp;&nbsp;&nbsp; (method extension 1),<br>
&nbsp;&nbsp;&nbsp; (method extension 2)<br>
&nbsp;&nbsp; },<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp; etc... (up to 16 methods)<br>
&nbsp;&nbsp; }<br>
&nbsp;}<br>
}</span></code><br>
<dl>
<dt><span style="font-weight: bold;">Options</span><br>
</dt>
</dl>
<dl>
<dd>Options&nbsp;determine
the range of options that are available to the user in the game setup
menu when starting a game using this system program.&nbsp;</dd>
<dd></dd>
<dd>They are in the format:<br>
</dd>
</dl>
<code><span class="excode">{(whether user can change
this setting (0 or 1)), (default value), (minimum value), (maximum
value)}</span></code><br>
<dl>
<dd>If the first field is 0, the user won't be able to change
this value. The (default value) will be used.</dd>
<li></li>
<dd>If (minimum value) or (maximum value) is 0, the minimum or
maximum possible value will be used.<br>
</dd>
</dl>
<dl>
<dd>An example of the Options: number of turns field:<br>
</dd>
</dl>
<code><span class="excode">{1, 5, 1, 10}, <span style="color: rgb(153, 153, 255);">// 1 means the user can
change this value. They will be able to set the turns from 1 to 10,
with a default of 5.</span></span></code><br>
<dl>
<dd>An example of the Options: width of game area field:</dd>
</dl>
<code><span class="excode">{0, 30}, <span style="color: rgb(153, 153, 255);">// the user can't change
this value. The area must be 30 blocks wide.</span></span></code><br>
<dl style="font-weight: bold;">
<dt>Allow player clients</dt>
</dl>
<dl>
<dd>If 1, players have access to client program templates and
can load client programs into them.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Player number of operator</dt>
</dl>
<dl>
<dd>This
is the player who gets to be the operator (i.e. they can load an
operator program into their client program template, while other
players can just load delegate programs). Set to -1 if there is no
operator.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>Allow user observer</dt>
</dl>
<dl>
<dd>If 1,
there will be an observer template. If 0, there won't be. If there is
no operator, this should be 1 (unless the system program is handling
user input).</dd>
</dl>
<dl style="font-weight: bold;">
<dt>May change client template</dt>
</dl>
<dl>
<dd>The system program can lock templates so that users can't
change them. This doesn't prevent the system program making changes. An
example:<br>
</dd>
</dl>
<code><span class="excode">{0, 1, 1, 1}, <span style="color: rgb(153, 153, 255);">// player 1 can't change
its client template. Players 2, 3 and 4 can.</span></span></code><br>
<span style="font-weight: bold;">May change process
templates</span>
<dl>
<dd>The same, but for process templates.</dd>
</dl>
<br>
This is an example of a system program interface (from the sy_multi.c
multiplayer system program):<br>
<br>
<code><span class="excode">interface<br>
{<br>
&nbsp;PROGRAM_TYPE_SYSTEM,<br>
&nbsp;<span style="color: rgb(153, 153, 255);">// The
following are: option, default, min, max</span><br>
&nbsp;<span style="color: rgb(153, 153, 255);">// If
min or max is left as 0, the game's actual min/max values will be used</span><br>
&nbsp;{1, 2, 2}, <span style="color: rgb(153, 153, 255);">//
players</span><br>
&nbsp;{1, 3, 1}, <span style="color: rgb(153, 153, 255);">//
turns</span><br>
&nbsp;{1, 5, 1}, <span style="color: rgb(153, 153, 255);">//
minutes per turn</span><br>
&nbsp;{1, 100}, <span style="color: rgb(153, 153, 255);">//
processes per team</span><br>
&nbsp;{1, 400}, <span style="color: rgb(153, 153, 255);">//
packets per team</span><br>
&nbsp;{1, 60}, <span style="color: rgb(153, 153, 255);">//
width of world</span><br>
&nbsp;{1, 60}, <span style="color: rgb(153, 153, 255);">//
height of world</span><br>
&nbsp;1, <span style="color: rgb(153, 153, 255);">//
allow_player_clients</span><br>
&nbsp;-1, <span style="color: rgb(153, 153, 255);">//
index of player who is operator (is -1 if no operator)</span><br>
&nbsp;1, <span style="color: rgb(153, 153, 255);">//
allow_user_observer</span><br>
&nbsp;{1, 1, 1, 1}, <span style="color: rgb(153, 153, 255);">//
may_change_client_template</span><br>
&nbsp;{1, 1, 1, 1}, <span style="color: rgb(153, 153, 255);">//
may_change_proc_templates</span><br>
&nbsp;{<br>
&nbsp; {MT_SY_PLACE_PROC},<br>
&nbsp; {MT_NONE}, <span style="color: rgb(153, 153, 255);">//
space for PLACE_PROC</span><br>
&nbsp; {MT_SY_TEMPLATE},<br>
&nbsp; {MT_SY_MODIFY},<br>
&nbsp; {MT_SY_MANAGE},<br>
&nbsp; {MT_NONE}, <span style="color: rgb(153, 153, 255);">//
space for MANAGE</span><br>
&nbsp; {MT_OB_VIEW},<br>
&nbsp; {MT_NONE}, <span style="color: rgb(153, 153, 255);">//
space for VIEW</span><br>
&nbsp; {MT_OB_CONSOLE},<br>
&nbsp; {MT_CLOB_CHANNEL},<br>
&nbsp; {MT_CLOB_QUERY},<br>
&nbsp; {MT_CLOB_WORLD},<br>
&nbsp; {MT_CLOB_MATHS},<br>
&nbsp;}<br>
}<br>
</span></code><br>
<br>
<h2><a class="mozTocH2" name="mozTocId484629"></a><a name="Shapes"></a> 5.4 More on process interfaces:
shapes and sizes</h2>
<br>
Each
process' interface must set a shape and size for the process. A
process' shape affects how many vertices it has available for external
methods, how robust it is, how large its irpt and data buffers are and
its maximum method mass capacity. A process' size
affects&nbsp;these
things as well (except for number of vertices).<br>
<br>
The following shapes are available:<br>
<br>
SHAPE_3TRIANGLE<br>
SHAPE_4SQUARE<br>
SHAPE_4DIAMOND<br>
SHAPE_4POINTY<br>SHAPE_4TRAP<br>SHAPE_4IRREG_L<br>SHAPE_4IRREG_R<br>SHAPE_4ARROW<br>SHAPE_5PENTAGON<br>
SHAPE_5POINTY<br>
SHAPE_5LONG<br>SHAPE_5WIDE<br>
SHAPE_6HEXAGON<br>
SHAPE_6POINTY<br>
SHAPE_6LONG<br>SHAPE_6IRREG_L<br>SHAPE_6IRREG_R<br>SHAPE_6ARROW<br>SHAPE_6STAR<br>SHAPE_8OCTAGON<br>
SHAPE_8POINTY<br>SHAPE_8LONG<br>SHAPE_8STAR<br><br>
Size can be 0, 1, 2 or 3.<br>
<br>
Here's what the shapes look like, and the attributes for each size of
each shape:<br>
<br><img style="width: 1000px; height: 2079px;" alt="Picture of various process shapes" src="shapes.png"><br>
<br>
The attributes are:<br>
<dl style="font-weight: bold;">
<dt>base mass</dt>
</dl>
<dl>
<dd>The
"mass" of a process represents how much data it consists of. The
heavier a process is, the more slowly it accelerates and
the&nbsp;more
momentum it carries. The data cost of creating a process is equal to
its mass. Base mass is the mass a process has with no methods at all.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>max method mass</dt>
</dl>
<dl>
<dd>Each
method has a&nbsp;build cost which determines how much data it
costs to
add to a process, with method extensions increasing this cost. A
shape's maximum method mass is the upper limit on the amount of method
mass a process can have. If a process' interface gives it too much
method mass, any method that would cause it to go overweight is
replaced by an error.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>max hp</dt>
</dl>
<dl>
<dd>This is how much damage the process can take before
deallocating. It can be increased by the <a href="#Redundancy:_MT_PR_REDUNDANCY">MT_PR_REDUNDANCY method</a>.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>irpt buffer</dt>
</dl>
<dl>
<dd>This is how many irpt the process can hold at once. The
size of a process' irpt buffer can't be increased.</dd>
</dl>
<dl style="font-weight: bold;">
<dt>data buffer</dt>
</dl>
<dl>
<dd>This is how much data the process can hold at once. It can
be increased by the <a href="#Storage:_MT_PR_STORAGE">MT_PR_STORAGE
method</a>.</dd>
</dl>
<br>
<h2><a class="mozTocH2" name="mozTocId813054"></a><a name="data_box"></a> 5.5 The process data box</h2>
<br>
The
process data box shows up when a process is selected (at least when you
are using the observer and operator programs that come with the game).
It looks like this:<br>
<br><img style="width: 507px; height: 483px;" alt="picture of process data box" src="data_box.png"><br>
<br>
Here's what the various fields mean:<br>
<ul>
<li><span style="font-weight: bold;">header
("Process 1"): </span>the number in the header is the process'
index. Process
indices are invisible to processes themselves, but
clients,&nbsp;observers and system programs can refer to processes
by
their indices.</li>
<li><span style="font-weight: bold;">hp</span>: how much damage the process can take (the number in brackets is the maximum).</li><li><span style="font-weight: bold;">ex</span>: the number of ticks until the process' next&nbsp;execution cycle.</li><li><span style="font-weight: bold;">at (x,y)
speed s (x,y): </span>this is the location of the
process (in pixels, from the top left of the world), and its speed (in
pixels per tick, multiplied by 16 to avoid underflow), and the x and y components of its speed.</li>
<li><span style="font-weight: bold;">angle</span>
is the direction the process' vertex 0 is pointing in, in integer
degrees (from 0 to 8192, where 0 is right).</li>
<li><span style="font-weight: bold;">spin</span>
is the process' rate of rotation (positive is clockwise, negative is
anticlockwise).</li><li><span style="font-weight: bold;">block</span> is the 128x128 pixel block the process is in (this isn't really useful, other than for debugging the game itself)</li>

<li><span style="font-weight: bold;">irpt</span>
is the process' interrupt buffer (the number in brackets is the maximum
size of the buffer). If the process is connected with other processes, this is the shared buffer.<span style="font-weight: bold;"></span><br></li>
<li><span style="font-weight: bold;">base</span>
is the base upkeep cost of the process. It must pay this many irpt each
time it executes, or it will take damage and eventually deallocate.</li>
<li><span style="font-weight: bold;">data</span>
is the process' data buffer (followed by its maximum). If the process is connected with other processes, this is shared.</li>
<li><span style="font-weight: bold;">instr</span>
is the number of instructions the process had left after its last
execution, with the number available in brackets. </li>
<li><span style="font-weight: bold;">used</span>
is the number of instructions it used.</li>
<li><span style="font-weight: bold;">size</span>
is the process' size</li>
<li><span style="font-weight: bold;">mass</span>
is the total mass of the process, equal to the base mass of its shape
plus the total mass of all of its methods (the number in brackets is
the maximum mass for its shape and size).</li>
<li><span style="font-weight: bold;">moment</span>
is the process' moment of inertia (currently for a single process this
is the same as its mass). This determines how much force is needed to
make the process rotate.</li><li><span style="font-weight: bold;">base mass</span> is the basic mass of the process without any methods.</li><li><span style="font-weight: bold;">method mass</span>
is the total mass of the process' methods, with the maximum in
brackets. The process' total mass is the sum of this and its base mass.</li>
</ul>
If the process is a member of a group of linked processes, there will
be another line here:<br>
<ul>
<li><span style="font-weight: bold;">group mass</span>
is the total mass of the group.</li>
<li><span style="font-weight: bold;">moment</span>
is the moment of inertia of the group as a whole. I wouldn't say that
the game simulates angular momentum very well, but it tries.</li>
<li><span style="font-weight: bold;">spin</span>
is the spin of the group as a whole.</li>
</ul>
<span style="font-weight: bold;">commands</span>
show the state of each of the process' 16 command registers.<br>
<br>
<span style="font-weight: bold;">Methods</span>
lists the process' methods in order.<br>
First is the name of the method, followed by its four method registers.<br>
A method that takes up multiple slots will be followed by sub-method
slots .These also have method registers.<br>
<br>
On the next line is the method's mass (<span style="font-weight: bold;">m</span>), followed by some
other things that depend on what kind of method it is:<br>
<ul>
<li><span style="font-weight: bold;">vx</span>
indicates which vertex an external method is on.</li>
<li><span style="font-weight: bold;">ang</span>
indicates the angle an external directional method is pointing (as an
offset from angle 0 of the vertex the method is on).</li>
<li><span style="font-weight: bold;">extensions</span>,
for methods that have extensions (e.g. a scan method might have range+1).</li>
<li>some methods give other information here as well (e.g. <a href="#Interrupt_generator:_MT_PR_IRPT">MT_PR_IRPT</a>
gives the method's maximum generation capacity per tick).</li><br>
</ul>
<h1><a class="mozTocH1" name="mozTocId329052"></a><span class="chapter"><a name="Chapter:_Methods"></a>
6. Methods</span></h1>
<br>
<span class="chapter"></span>A method is a special
capability, function or characteristic of a
program. Methods are part of a program's interface; each program's
interface has 16 slots for methods, although some methods take up
multiple slots.<br>
<br>
Each type of program has a different set of methods available to it.<br>
<br>
<ul>
<li>A process can use MT_PR method types, like <a href="#Movement:_MT_PR_MOVE">MT_PR_MOVE</a> (which
lets a
process move) or <a href="#Interrupt_generator:_MT_PR_IRPT">MR_PR_IRPT</a>
(which generates interrupts for the process
to use).</li>
</ul>
<ul>
<li>A delegate program can use MT_CL method types, like <a href="#Command_client:_MT_CL_COMMAND">MT_CL_COMMAND</a>
(which
lets the delegate program issue commands to processes). Delegate
programs can also use MT_CLOB
method types, which are also available to observer programs.
</li>
</ul>
<ul>
<li>An observer program can use MT_OB method types, like <a href="#Input:_MT_OB_INPUT">MT_OB_INPUT</a> (which
lets the observer program read user input from the mouse and keyboard).
Observer programs can use MT_CLOB method types too.</li>
</ul>
<ul>
<li>An operator program can use all MT_CL, MT_OB and MT_CLOB
method types.
It is the ability to use user input methods as well as the command
method that lets operator programs translate user input into control
over processes.</li>
</ul>
<ul>
<li>A system program can use all MT_CL, MT_OB and MT_CLOB
methods, as well
as MT_SY methods like <a href="#Manage:_MT_SY_MANAGE">MT_SY_MANAGE</a>
(which gives the system program
overall control over the game).</li>
</ul>
<ul>
<li>There are also MT_ERROR methods, which indicate various
kinds of error
in a program's interface definition.</li>
</ul>
All methods are fail-safe; if they receive invalid instructions, or if
they encounter an error of some kind when activated, they will return
without otherwise affecting their process or program. In some cases
they will return a value indicating why they failed.<br>
<br>
<a href="#Process_methods_PR"><span style="font-weight: bold;">Process methods</span></a><br>
<ul>
<li><a href="#Movement:_MT_PR_MOVE">Movement</a>
(MT_PR_MOVE): Allows a process to accelerate.</li>
<li><a href="#New:_MT_PR_NEW">New process</a>
(MT_PR_NEW): Allows a process to create other processes.</li>
<li><a href="#New_sub:_MT_PR_NEW_SUB">New process
(sub)</a>
(MT_PR_NEW_SUB): Allows a process to create other
processes, with some limitations that make this method more suited to
creating parts of a multi-process group than to creating whole new
processes.</li>
<li><a href="#Packet:_MT_PR_PACKET">Malicious
packet</a> (MT_PR_PACKET): Allows a process to attack other
processes.</li>
<li><a href="#Directional_packet:_MT_PR_DPACKET">Directional
packet</a> (MT_PR_DPACKET): Like MT_PR_PACKET, but can be aimed.</li>
<li><a href="#Stream:_MT_PR_STREAM">Stream</a>
(MT_PR_STREAM): More effective, but more expensive, than packet methods.</li><li><a href="Manual.html#Stream:_MT_PR_STREAM">Directional Stream</a>
(MT_PR_DSTREAM): Like MT_PR_DPACKET for streams.</li>
<li><a href="#Scan:_MT_PR_SCAN">Scan</a>
(MT_PR_SCAN): Allows a process to scan its surroundings
for other processes.</li>
<li><a href="#Interrupt_generator:_MT_PR_IRPT">Interrupt
generator</a> (MT_PR_IRPT): Allows a process to generate energy.</li>
<li><a href="#Data_allocator:_MT_PR_ALLOCATE">Data
allocator</a> (MT_PR_ALLOCATE): Allows a process to allocate data
from its surroundings, and also makes process immobile.</li>
<li><a href="#Information:_MT_PR_STD">Standard</a> (MT_PR_STD): Provides various standard functions.</li>

<li><a href="#Mathematics:_MT_PR_MATHS">Mathematics</a>
(MT_PR_MATHS): Performs various calculations, including
trigonometry.<a href="#Channel:_MT_PR_CHANNEL"></a><br></li>
<li><a href="#Designate:_MT_PR_DESIGNATE">Designate</a>
(MT_PR_DESIGNATE): Allows a process to designate another
process as a target, then find it again.</li>
<li><a href="#Link:_MT_PR_LINK">Link</a>&nbsp;(MT_PR_LINK):
Allows a process to connect to another
process (which must also have a link method)</li>

<li><a href="#Restore:_MT_PR_RESTORE">Restore</a>
(MT_PR_RESTORE): Allows a process to repair itself.</li>
<li><a href="#Redundancy:_MT_PR_REDUNDANCY">Redundancy</a>
(MT_PR_REDUNDANCY): Makes a process more robust.</li>
<li><a href="#Broadcast:_MT_PR_BROADCAST">Broadcast</a>
(MT_PR_BROADCAST): Sends brief messages to nearby processes.</li>
<li><a href="#Listen:_MT_PR_LISTEN">Listen</a>
(MT_PR_LISTEN): Lets a process hear broadcast messages.</li>
<li><a href="#Yield:_MT_PR_YIELD">Yield</a>
(MT_PR_YIELD): Sends irpt and data to nearby processes.</li>
<li><a href="#Storage:_MT_PR_STORAGE">Storage</a>
(MT_PR_STORAGE): Increases a process' data storage buffer.</li>
<li><a href="#Static:_MT_PR_STATIC">Static</a>
(MT_PR_STATIC): Makes a process immobile.</li>
<li><a href="#Command_process:_MT_PR_COMMAND">Command
(process)</a> (MT_PR_COMMAND): Allows a process to communicate
with
a client program using the process' command registers.</li>
<li><a href="#Virtual:_MT_PR_VIRTUAL"><span style="text-decoration: underline;">Virtual</span> interface</a> (MT_PR_VIRTUAL): Protects a process from damage, but costs a lot of IRPT.<br>
</li>
</ul>
<a href="#Client_methods_CL"><span style="font-weight: bold;">Client methods</span></a><br>
<ul>
<li><a href="#Command_client:_MT_CL_COMMAND_GIVE">Command-give
(client)</a> (MT_CL_COMMAND_GIVE): Allows a client program to
communicate with processes via their command registers.</li>
<li><a href="#Template:_MT_CL_TEMPLATE">Template
(client)</a> (MT_CL_TEMPLATE): Allows a client program to copy
code from itself into a template.<br></li>
</ul>
<a href="#ClientObserver_methods_CLOB"><span style="font-weight: bold;">Client/observer methods</span></a><br>
<ul>
<li><a href="#Check_point:_MT_CLOB_POINT">Point
check</a> (MT_CLOB_POINT): Allows a client/observer to check
whether
a process exists at a specified point, and a few other similar things.</li>
<li><a href="#Query:_MT_CLOB_QUERY">Query process</a>
(MT_CLOB_QUERY): Allows a client/observer to get
information about a process (similar to the MT_PR_INFO method).</li>
<li><a href="#Scan_clob:_MT_CLOB_SCAN">Scan (clob)</a>
(MT_CLOB_SCAN): Allows a client/observer to scan
areas of the world for processes (has additional modes that MT_PR_SCAN
doesn't have).</li>
<li><a href="#Maths_clob:_MT_CLOB_MATHS">Mathematics</a>
(MT_CLOB_MATHS): The same as MT_PR_MATHS.</li>
<li><a href="#Standard_CLOB:_MT_CLOB_STD">Standard</a> (MT_CLOB_STD): Provides various standard functions (although not quite the same ones as MT_PR_STD).</li>
<li><a href="#Command_rec:_MT_CLOB_COMMAND_REC">Command-receive</a> (MT_CLOB_COMMAND_REC): Allows the program to read process' command registers.<br>
</li>
</ul>
<a href="#Observer_methods_OB"><span style="font-weight: bold;">Observer methods</span></a><br>
<ul>
<li><a href="#Input:_MT_OB_INPUT">Input</a>
(MT_OB_INPUT): Allows the observer to receive input from the user.</li>
<li><a href="#View:_MT_OB_VIEW">View</a>
(MT_OB_VIEW): Sets up the screen display in various ways.</li>
<li><a href="#Console:_MT_OB_CONSOLE">Console</a>
(MT_OB_CONSOLE): Controls the placement and function of text
consoles.</li>
<li><a href="#Select:_MT_OB_SELECT">Select</a>
(MT_OB_SELECT): Allows the observer to place minor graphical
elements on the display, to indicate things like selected processes.</li>
<li><a href="#Control:_MT_OB_CONTROL">Control</a>
(MT_OB_CONTROL): Gives various pieces of information about the
game settings, and lets the observer communicate with the system
program.<br>
</li>
</ul>
<a href="#System_methods_SY"><span style="font-weight: bold;">System methods</span></a><br>
<ul>
<li><a href="#Place:_MT_SY_PLACE">Place process</a>
(MT_SY_PLACE_PROC): Allows the system program to place
processes in the world.</li>
<li><a href="#Template:_MT_SY_TEMPLATE">Template</a>
(MT_SY_TEMPLATE): Allows the system program to manipulate
templates.</li>
<li><a href="#Modify_process:_MT_SY_MODIFY">Modify
process</a> (MT_SY_MODIFY_PROC): Allows the system program to
change
various things about processes.</li>
<li><a href="#Manage:_MT_SY_MANAGE">Manage</a>
(MT_SY_MANAGE): Allows the system program to manage various
things about the game, like declaring a winner.<br>
</li>
</ul>
<span style="font-weight: bold;"><a name="Special_methods"></a>Special methods</span><br>
<ul>
<li>End (MT_END): Indicates the end of a program's methods (you
don't need
to worry about this one; it's added automatically).</li>
<li>Invalid type error (MT_ERROR_INVALID): Indicates an invalid
method type
in a program's interface definition.</li>
<li>Duplicate method error (MT_ERROR_DUPLICATE): Some methods
cannot be
duplicated.</li>
<li>Invalid vertex error (MT_ERROR_VERTEX): Indicates an
external method
with an invalid vertex (e.g. a method put on vertex 7 of a hexagon).</li>
<li>Invalid mass error (MT_ERROR_MASS): Indicates that the
method would
have caused its process to be overweight.</li>
<li>New sub method error (MT_ERROR_SUB): Indicates that the process was created with the MT_PR_NEW_SUB method, but a method that a
NEW_SUB method cannot create was in the process' interface.</li>
</ul>
<br>
<span style="font-weight: bold;">Attributes of
process&nbsp;methods</span><br>
<dl>
<dt>External</dt>
</dl>
<dl>
<dd>An external method occupies one of the process' external
vertices
(which vertex it occupies is set by the process' interface). If two
external methods are given the same vertex, the second one will fail
and be replaced with an MT_ERROR_VERTEX error. A process can't have
more external methods than it has vertices.</dd>
</dl>
<dl>
<dt>Internal</dt>
</dl>
<dl>
<dd>An internal method doesn't occupy a vertex.</dd>
</dl>
Automatic
<dl>
<dd>An automatic method operates between process executions,
usually based
on the settings in its method bank registers. For example, the <a href="#Movement:_MT_PR_MOVE">MOVE</a>
method can be set to accelerate the process constantly until the next
program execution 16 ticks later.</dd>
</dl>
<dl>
<dt>Called</dt>
</dl>
<dl>
<dd>A called method does something when called using the
compiler's <a href="#built-in_function:_call">call()
built-in function</a> or the assembler's <a href="#asm:_call_instructions">call instructions</a>,
and may also
return a value. For example, when the <a href="#Mathematics:_MT_PR_MATHS">MATHS</a> method is
called it
performs a calculation on values in its method bank registers and
returns the result.</dd>
</dl>
<dl>
<dt>Not called</dt>
</dl>
<dl>
<dd>Does nothing when called, and returns 0.</dd>
</dl>
<dl>
<dt>Directional</dt>
</dl>
<dl>
<dd>An external method may point in a particular direction,
which is
determined by the angle field in its interface definition. For example,
the <a href="#Packet:_MT_PR_PACKET">PACKET</a>
method fires a packet in its specified direction. An
external method's direction generally cannot point inwards.</dd>
</dl>
<dl>
<dt>Single</dt>
</dl>
<dl>
<dd>A process can only have one method of this type. Any others
will be
replaced by an MT_ERROR_DUPLICATE error.</dd>
</dl>
<br>
<span style="font-weight: bold;">Method costs</span><br>
<br>
Each process method has the following costs:<br>
<ul>
<li>A base data cost, which is added to the data cost (and
therefore also the irpt cost) of any process that
includes the method.</li>
</ul>
<ul>
<li>A maintenance interrupt cost which must be paid each time
the process
executes.</li>
</ul>
<ul>
<li>Data and interrupt costs, and maintenance irpt costs, for
each extension added to the method.</li>
</ul>
These depend on the method's cost category:<br>
<ul>
<li>Minimal: base data and maintenance cost 2, extension data
and maintenance cost 1</li>
</ul>
<ul>
<li>Low: base data and maintenance cost 4, extension data and
maintenance cost 2</li>
</ul>
<ul>
<li>Medium: base data and maintenance cost 8, extension data
and maintenance cost 4</li>
</ul>
<ul>
<li>High: base data and maintenance cost 16, extension data and
maintenance cost 8</li>
</ul>
<ul>
<li>Ultra: base data and maintenance cost 32, extension data
and maintenance cost 16<br>
</li>
</ul>
Some
methods also have additional costs which must be paid when the method
is used. This is mentioned in the method descriptions below.<br>
<br>
<h2><a class="mozTocH2" name="mozTocId627354"></a><a name="Process_methods_PR"></a> 6.1 Process methods (PR)</h2>
<br>
These start with MT_PR. Some process methods have extensions, which
make them more effective in various ways but increase their cost. A
process methods' extensions are set in the process' interface.<br>
<br>
<span class="method"><a name="Movement:_MT_PR_MOVE"></a>Movement:
MT_PR_MOVE</span><br>
This method allows processes to move and rotate. It works like a jet,
accelerating the process away from the direction it is pointing, and
also generating torque.<br>
<br>
External, directional, automatic, not called<br>
Cost: High<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>
0: power<br>
<br>
<br>
<span style="font-weight: bold;">Registers</span><br>
<dl>
<dt>MB_PR_MOVE_RATE</dt>
</dl>
<dl>
<dd>Acceleration rate (basically, power level).</dd>
</dl>
<dl>
<dt>MB_PR_MOVE_COUNTER</dt>
</dl>
<dl>
<dd>Number of ticks to operate for (set to zero to turn
method off)</dd>
</dl>
<dl>
<dt>MB_PR_MOVE_DELAY</dt>
</dl>
<dl>
<dd>Delay before starting to operate</dd>
</dl>
To use:<br>
<ol class="list">
<li>Set the rate register to the acceleration rate you want.
Usually
this is the maximum, which is 5+(3*power extension), but if you set the
rate register above this it will just work at the maximum.</li>
<li>Set the counter register to the number of ticks that the
method
should operate for. If you set this to 16 or more, the method will
provide thrust until the process' next execution.</li>
<li>Set the delay register to the number of ticks to wait
before the
method starts operating. Set to 0 if you don't want a delay. The
counter register doesn't count down during this delay.</li>
</ol>
Using it costs 2 interrupts per rate per tick. So if you set it to run
for 16 ticks at rate 5, it will cost 160 interrupts.<br>
<br>
<br>
<span class="method"><a name="New:_MT_PR_NEW"></a>New:
MT_PR_NEW</span><br>
This method allows a process to create another process. The new
process' bcode can be copied from the parent process' own bcode, or
from a template.<br>
<br>
Internal, called<br>
Cost: Ultra<br>
Size 2 (method registers: 8)<br>
<br>
Extensions: none<br>
<br>
<span style="font-weight: bold;">Registers</span><br>
<dl>
<dt>MB_PR_NEW_STATUS</dt>
</dl>
<dl>
<dd>Sets the mode of operation (see <a href="#New_method:_statuses">MS_PR_NEW_* values</a>
below).</dd>
</dl>
<dl>
<dt>MB_PR_NEW_VERTEX1</dt>
</dl>
<dl>
<dd>The vertex of the parent process that the new
process will be created at.</dd>
</dl>
<dl>
<dt>MB_PR_NEW_VERTEX2</dt>
</dl>
<dl>
<dd>The vertex of the new process that will start in
contact with VERTEX1 of the parent process. Set to -1 to use the new
process' base_vertex interface value (specified in the new process'
interface definition).</dd>
</dl>
<dl>
<dt>MB_PR_NEW_ANGLE </dt>
</dl>
<dl>
<dd>The angle the new process will have when created
(relative to the angle of the parent process' vertex). At angle 0, the
new process' vertex set by the vertex2 register will be pointing
directly towards the parent process.</dd>
</dl>
<dl>
<dt>MB_PR_NEW_START</dt>
</dl>
<dl>
<dd>The start address of the new process' bcode, in the
source bcode.</dd>
</dl>
<dl>
<dt>MB_PR_NEW_END</dt>
</dl>
<dl>
<dd>The end address.</dd>
</dl>
<dl>
<dt>MB_PR_NEW_LINK</dt>
</dl>
<dl>
<dd>If both processes have <a href="#Link:_MT_PR_LINK">MT_PR_LINK
methods</a> at their
mutual vertices, this can be set to 1 and the processes will be
connected.</dd>
</dl>
<dl>
<dt>MB_PR_NEW_TEMPLATE</dt>
</dl>
<dl>
<dd>If the new process is being created from a
template, this is the index of the template (0 to 3).</dd>
</dl>
<br>
<span style="font-weight: bold;"><a name="New_method:_statuses"></a>Statuses</span><br>
<dl>
<dt>MS_PR_NEW_NOTHING</dt>
</dl>
<dl>
<dd>The method will do nothing.</dd>
</dl>
<dl>
<dt>MS_PR_NEW_BC_BUILD</dt>
</dl>
<dl>
<dd>The method will attempt to create a new process.
The new process' bcode will be copied from the parent process' own
bcode. The method will return an <a href="#MR_NEW_values">MR_PR_NEW_*
result value</a>.</dd>
</dl>
<dl>
<dt>MS_PR_NEW_BC_TEST</dt>
</dl>
<dl>
<dd>The method will test whether a new process
can be created. It will make sure that the values in the method's
registers are correct, that the new process' interface allows it to be
created (e.g. it must have valid shape and size values), that the
parent process has sufficient data and irpt, and that the new process
will not collide with an existing process.</dd>
</dl>
<dl>
<dt>MS_PR_NEW_BC_COST_DATA</dt>
</dl>
<dl>
<dd>The method will work out the data cost of
building a new process with from the specified bcode.</dd>
</dl>
<dl>
<dt>MS_PR_NEW_BC_COST_IRPT</dt>
</dl>
<dl>
<dd>The same, but for irpt cost.</dd>
</dl>
MS_PR_NEW_T_BUILD<br>
<dl>
<dd>Like MS_PR_NEW_BC_BUILD, but the method will try to
build from one of its player's process templates. The
MB_PR_NEW_TEMPLATE register indicates which template to use.</dd>
</dl>
<dl>
<dt>MS_PR_NEW_T_TEST</dt>
</dl>
<dl>
<dd>Like MS_PR_NEW_BC_TEST, but for templates.</dd>
</dl>
<dl>
<dt>MS_PR_NEW_T_COST_DATA</dt>
</dl>
<dl>
<dd>Data cost of building from a template.</dd>
</dl>
<dl>
<dt>MS_PR_NEW_T_COST_IRPT</dt>
</dl>
<dl>
<dd>irpt cost of building from a template (currently this is the same as the data cost).</dd>
</dl>
<br>
<span style="font-weight: bold;"><a name="MR_NEW_values"></a>Return
values</span><br>
<br>
Calling the method will return one of the following:<br>
<dl>
<dt>MR_NEW_NONE</dt>
</dl>
<dl>
<dd>No result.</dd>
</dl>
<dl>
<dt>MR_NEW_SUCCESS</dt>
</dl>
<dl>
<dd>The new process was successfully built.</dd>
</dl>
<dl>
<dt>MR_NEW_TEST_SUCCESS</dt>
</dl>
<dl>
<dd>The test was successful.</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_STATUS</dt>
</dl>
<dl>
<dd>Unrecognised MB_PR_NEW_STATUS value.</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_TYPE</dt>
</dl>
<dl>
<dd>The interface definition in the source bcode
indicates that it is not a process (this can happen if e.g. you try to
build a process from a system program).</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_OBSTACLE</dt>
</dl>
<dl>
<dd>The process would collide with another process,
or the edge of the map, if created (the specified location of the new
process is indicated on screen for a short time).</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_IRPT</dt>
</dl>
<dl>
<dd>The parent process does not have enough irpt.</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_DATA</dt>
</dl>
<dl>
<dd>Not enough data.</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_START_BOUNDS</dt>
</dl>
<dl>
<dd>The start address specified in the start
address register is out of bounds.</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_END_BOUNDS</dt>
</dl>
<dl>
<dd>The end address is out of bounds.</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_INTERFACE</dt>
</dl>
<dl>
<dd>There is a problem with the new process'
interface definition.</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_TOO_MANY_PROCS</dt>
</dl>
<dl>
<dd>The player already has too many processes.</dd>
</dl>
MR_NEW_FAIL_SHAPE<dl>
</dl>
<dl>
<dd>The shape specified in the process' interface is
invalid.</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_SIZE</dt>
</dl>
<dl>
<dd>The size specified in the process' interface is
invalid.</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_PARENT_VERTEX</dt>
</dl>
<dl>
<dd>The parent vertex register value is invalid.</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_CHILD_VERTEX</dt>
</dl>
<dl>
<dd>The new process vertex register value is
invalid.</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_TEMPLATE</dt>
</dl>
<dl>
<dd>The template index in the template register is
invalid.</dd>
</dl>
<dl><dt>MR_NEW_FAIL_TEMPLATE_EMPTY</dt></dl><dl><dd>The template&nbsp;indicated by the template register is empty.</dd></dl>
<dl><dt>MR_NEW_FAIL_LOCATION</dt>
</dl>
<dl>
<dd>Invalid location (only returned by the
<a href="#Place:_MT_SY_PLACE">MT_SY_PLACE method</a>)</dd>
</dl>
<dl>
<dt>MR_NEW_FAIL_PLAYER</dt>
</dl>
<dl>
<dd>Invalid player index (only returned by the
<a href="#Place:_MT_SY_PLACE">MT_SY_PLACE method</a>)</dd>
</dl>
<br>
The amount of data required to create a new process is equal to the
mass of the process. A process' mass is the sum of its base mass,
determined by its shape and size (see process shapes), and the total
mass of all of its methods. <br>
<br>
The irpt cost of building a new process is the same as the data cost.<br>
<br>
There
is also some overhead for calling this method: 64 irpt for a build
call, and 32 irpt for any other call (such as a test, or a cost query).
If the parent process has insufficient irpt, the method will return
MR_NEW_FAIL_IRPT.<br>
<br>
An example of a simple use of this method to create a new process based
on a sub-process of the parent process:<br>
<br>
<code><span class="excode">build_result =
call(METH_NEW,<br>
&nbsp;MS_PR_NEW_BC_BUILD, <span style="color: rgb(153, 153, 255);">// status: try to build a
new process using bcode copied from the parent process</span><br>
&nbsp;3, <span style="color: rgb(153, 153, 255);">//
vertex1: the new process will be built at the parent process' vertex 3</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
vertex2: the new process' vertex 0 will be next to the parent process'
vertex 3</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
angle: the new process' vertex 0 will be pointing directly towards the
parent process</span><br>
&nbsp;process_start(name_of_new_process),<br>
&nbsp;process_end(name_of_new_process),<span style="color: rgb(153, 153, 255);">
// these address values indicate that the new process' bcode is to be
copied from a subprocess of the parent called name_of_new_process</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
link: the new process will not be connected to the parent process</span><br>
&nbsp;0); <span style="color: rgb(153, 153, 255);">//
template: not relevant</span><br>
<br>
<span style="color: rgb(153, 153, 255);">// After this
call, build_result will hold one of the MR_NEW_? values.</span></span></code><code><span class="excode"></span></code><code><span class="excode"></span><span class="excode"></span></code>
<br class="excode">
<br>
An example of using this method to create a new process from a template:<br>
<br>
<code><span class="excode">build_result =
call(METH_NEW,<br>
&nbsp;MS_PR_NEW_T_BUILD,<span style="color: rgb(153, 153, 255);">
// status: try to build a new process using bcode copied from a template</span><br>
&nbsp;3, <span style="color: rgb(153, 153, 255);">//
vertex1: the new process will be built at the parent process' vertex 3</span><br>
&nbsp;-1, <span style="color: rgb(153, 153, 255);">//
vertex2: the new process' base vertex&nbsp;will be next to the
parent process' vertex 3</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
angle: the new process' vertex 0 will be pointing directly towards the
parent process</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
start address</span><br>
&nbsp;BCODE_SIZE_PROCESS - 1, <span style="color: rgb(153, 153, 255);">// end address: this is
the end of the template, so the entire template will be copied</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
link: the new process will not be connected to the parent process</span><br>
&nbsp;1); <span style="color: rgb(153, 153, 255);">//
template: this is the second of the player's 4 process templates</span></span></code><span class="excode"></span><br>
An example of the previous call, but as a test:<br>
<br>
<code><span class="excode">test_result =
call(METH_NEW,<br>
&nbsp;MS_PR_NEW_T_TEST, <span style="color: rgb(153, 153, 255);">//
status: try to build a new process using bcode copied from a template,
but &nbsp;stop before actually building it</span><br>
&nbsp;3, <span style="color: rgb(153, 153, 255);">//
vertex1: the new process will be built at the parent process' vertex 3</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
vertex2: the new process' vertex 0 will be next to the parent process'
vertex 3</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
angle: the new process' vertex 0 will be pointing directly towards the
parent process</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
start address</span><br>
&nbsp;BCODE_SIZE_PROCESS - 1, <span style="color: rgb(153, 153, 255);">// end address: this is
the end of the template, so the entire template will be copied</span><br>
&nbsp;0,<span style="color: rgb(153, 153, 255);"> //
link: the new process will not be connected to the parent process</span><br>
&nbsp;1); <span style="color: rgb(153, 153, 255);">//
template: this is the second of the player's 4 process templates<br>
<br style="color: rgb(153, 153, 255);">
</span><span style="color: rgb(153, 153, 255);">//
This is exactly the same, except for the status.</span></span></code><span class="excode"></span><br>
<br>
<span class="method"><a name="New_sub:_MT_PR_NEW_SUB"></a>New
(sub): MT_PR_NEW_SUB</span><br>
This method is the same as the <a href="#New:_MT_PR_NEW">MT_PR_NEW
method</a>, except that it cannot
create new processes which have either the MT_PR_NEW method or the
<a href="#Interrupt_generator:_MT_PR_IRPT">MT_PR_IRPT
method</a>, and it is cheaper (medium cost instead of ultra -
creating new processes costs the same, though). These limitations make
it suitable for doing things like creating new sub-processes linked to
a main process.<br>
<br>
Internal, called<br>
Cost: Medium<br>
Size 2 (method registers: 8)<br>
<br>
<br>
<span class="method"><a name="Packet:_MT_PR_PACKET"></a>Packet:
MT_PR_PACKET</span><br>
This method shoots out a malicious packet at your enemies.<br>
<br>
External, directional, automatic, not called<br>
Cost: High<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>
0: power (increases damage)<br>
1: speed (increases the packet's speed, although not its range)<br>
2: range (increases the packet's flight time)<br>
<br>
<span style="font-weight: bold;">Registers</span><br>
<dl>
<dt>MB_PR_PACKET_COUNTER</dt>
</dl>
<dl>
<dd>Number of ticks after the process executes at
which the method should fire. If this is &lt;= 0, the method won't
fire. Set to 1 to fire immediately. However, the method has an 8-tick
recycle period after firing during which it can't fire again. If the
counter reaches 1 during this period, it will fire at the end of it.</dd>
</dl>
<dl>
<dt>MB_PR_PACKET_FRIENDLY</dt>
</dl>
<dl>
<dd>If 1, the packet will hit friendly processes as
well as processes belonging to other players. If zero or any other
value, will only hit other players' processes. Since method registers
default to zero at program creation, you probably don't want to do
anything to this.<br>
</dd>
</dl>All you need to do to tell a packet method to fire is to set its
counter register to 1. The irpt cost of firing a packet is (2 + total
number of extensions) *
32, or 64 (0 extensions), 96 (1),&nbsp;128 (2), 160 (3) or 192 (4).<br><br>
<br>
<span class="method"><a name="Directional_packet:_MT_PR_DPACKET"></a>Directional
packet: MT_PR_DPACKET</span><br>
Like MT_PR_PACKET, but can rotate. In return for this it does a bit
less damage,&nbsp;has a slightly reduced speed and flight time, and
costs slightly more to use.<br>
<br>
External, directional, automatic, called<br>
Cost: High<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>
0: power (increases damage)<br>
1: speed (increases the packet's speed, although not its range)<br>
2: range (increases the packet's flight time)<br>
<br>
<span style="font-weight: bold;">Registers</span><br>
<dl>
<dt>MB_PR_DPACKET_COUNTER</dt>
</dl>
<dl>
<dd>Number of ticks after the process executes at
which the method should fire. If this is &lt;= 0, the method won't
fire. Set to 1 to fire immediately.</dd>
</dl>
<dl>
<dt>MB_PR_DPACKET_ANGLE</dt>
</dl>
<dl>
<dd>The method will turn towards this angle, at 32
integer degrees per tick. The angle should be an offset from the vertex
angle of the vertex the method is on. The method will not turn to an
inwards angle (it will stop at the edge). You can use the <a href="#built-in_functions:_data">data built-in
function</a> with the&nbsp;DATA_SHAPE_VERTEX_ANGLE_MIN and
DATA_SHAPE_VERTEX_ANGLE_MAX modes to work out the minimum and maximum
offsets from angle 0 that this method can point in.</dd>
</dl>
<dl>
<dt>MB_PR_DPACKET_FRIENDLY</dt>
</dl>
<dl>
<dd>If 1, the packet will hit friendly processes as
well as processes belonging to other players. If any other value, will
only hit other players' processes.</dd>
</dl>
<br>
The irpt cost of firing a packet is (2 + total number of
extensions) * 36, or 72 (0 extensions), 108 (1), 144 (2), 180 (3) or
216 (4).<br>
<br>
Calling this method returns its current angle.<br>
<br>
<br>
<span class="method"><a name="Stream:_MT_PR_STREAM"></a>Stream:
MT_PR_STREAM</span><br>
This method shoots out a stream of malicious data at your enemies. It
is more expensive than the packet methods, and costs a huge amount of
irpt to use, but is also very powerful.<br>
<br>
External, directional, automatic,&nbsp;called<br>
Cost: Ultra<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>
0: time (increases the amount of time the method can stay in its firing
phase)<br>
1: range (increases the range of the stream)<br>
2: recycle (reduces the time that it takes the method to be ready again after being used)<br>
<br>
<span style="font-weight: bold;">Registers</span><br>
<dl>
<dt>MB_PR_STREAM_FIRE</dt>
</dl>
<dl>
<dd>Set this to 1 to tell the method to fire as soon as it's ready.</dd>
</dl>This method has five phases:<br><ul><li>Ready: the method is ready to fire. It starts in this phase and automatically returns to it after the end of the recycle phase.</li><li>Warm-up: the stream is being generated and the method is using up irpt, but no damage is being caused yet.</li><li>Firing: the stream is causing damage. The central part of the stream gets brighter.</li><li>Cool-down: the stream is neither causing damage nor using irpt.</li><li>Recycle: the method can't be used.</li></ul>The warm-up phase lasts for 8 ticks.<br><br>The firing phase lasts for 6 + (3 * time extension) ticks. During the firing phase, the stream causes 36hp damage per tick.<br><br>Initiating
firing consumes 2048 + (512 *
number of extensions) irpt (which is a lot). Since no single process
has an irpt buffer that large, this method can only be used on
multi-part processes.<br><br>The cool-down phase lasts for 16 ticks, then the method enters the recycle phase.<br><br>The recycle phase lasts for 96 - (16 * recycle extension) ticks, then the method returns to the ready phase.<br><br>To
use the method, set the MB_PR_STREAM_FIRE register to 1. The next time
the method is in the ready phase (which may be immediately after it
finishes executing), it will enter the warm-up phase then begin firing.<br><br>When called, the method returns:<br><ul><li>0 if it is ready to fire;</li><li>-1 if it is currently in warm-up, firing or cool-down phase;</li><li>the number of ticks until it is ready to fire again if it is in recycle phase.</li></ul><br><br>
<span class="method"><a name="Stream:_MT_PR_DSTREAM"></a>Stream:
MT_PR_DSTREAM</span><br>This
is the directional version of the Stream method. It is less powerful
than Stream, causing 24hp damage per tick rather than 36.<br>
<br>
External, directional, automatic,&nbsp;called<br>
Cost: Ultra<br>
Size 1 (method registers: 4)<br><br>It
has an additional MB_PR_DSTREAM_ANGLE register that works just like the
MB_PR_DPACKET_ANGLE register. The method stops rotating while firing.<br><br><br>
<span class="method"><a name="Scan:_MT_PR_SCAN"></a>Scan:
MT_PR_SCAN</span><br>
This method scans a square area around a process to find other
processes that
meet certain criteria. When it finds them, it copies their location
into memory, in order of distance (nearest to furthest). It also has a
secondary "examine" mode that gives more information about a particular
nearby process.<br>
<br>
The centre of the scan can be set off from the process' actual
location, as long as the whole of the scanned area is within range. If
part of the scanned area would be out of range, the scanned area is
reduced so as to be a square that is entirely within range.<br>
<br>
Internal, called<br>
Cost: Medium<br>
Size 3 (method registers: 12)<br>
<br>
Extensions:<br>
0: range<br>
<br>
<br>
<span style="font-weight: bold;"><a name="Scan_method:_Registers"></a>Registers</span><br>
<dl>
<dt>MB_PR_SCAN_STATUS</dt>
</dl>
<dl>
<dd>This determines what the method does when called.
Should be an MS_PR_SCAN_* value.</dd>
</dl>
<dl>
<dt>MB_PR_SCAN_START_ADDRESS</dt>
</dl>
<dl>
<dd>The results of the scan will be copied into
the process' memory. This should be the address of the first element of
an array large enough to hold the results.</dd>
</dl>
<dl>
<dt>MB_PR_SCAN_NUMBER</dt>
</dl>
<dl>
<dd>The number of processes to find. When this number
has been reached, the scan will stop.</dd>
</dl>
<dl>
<dt>MB_PR_SCAN_X1</dt>
</dl>
<dl>
<dd>The x offset (in pixels) of the centre of the scan from
the process' location.</dd>
</dl>
<dl>
<dt>MB_PR_SCAN_Y1</dt>
</dl>
<dl>
<dd>y offset.</dd>
</dl>
<dl>
<dt>MB_PR_SCAN_SIZE</dt>
</dl>
<dl>
<dd>The scanned area is an orthogonal square around its
centre, with the edges being this number of pixels away from the centre.</dd>
</dl>
<dl>
<dt>MB_PR_SCAN_SIZE2</dt>
</dl>
<dl>
<dd>Not used for the MT_PR_SCAN method (but see
MT_CLOB_SCAN)</dd>
</dl>
MB_PR_SCAN_BITFIELD_WANT<br>
MB_PR_SCAN_BITFIELD_NEED<br>
MB_PR_SCAN_BITFIELD_REJECT
<dl>
<dd>See below for a discussion of the bitfields</dd>
</dl>
<br>
<span style="font-weight: bold;">Statuses</span><br>
<dl>
<dt>MS_PR_SCAN_SCAN</dt>
</dl>
<dl>
<dd>Performs a scan when called.</dd>
</dl>
<dl>
<dt>MS_PR_SCAN_EXAMINE</dt>
</dl>
<dl>
<dd>Performs examine when called.</dd>
</dl>
<br>
<span style="font-weight: bold;"><a name="Scan:_Return_values"></a>Return value</span><br>
<br>
In either mode, a successful scan returns the number of
processes found (which may be zero). An unsuccessful scan returns one
of the following result values:<br>
<dl>
<dt>MR_SCAN_FAIL_SIZE (-1)</dt>
</dl>
<dl>
<dd>Size is negative (a size that is positive but
too large is just reduced to a valid size).</dd>
</dl>
<dl>
<dt>MR_SCAN_FAIL_RANGE (-2)</dt>
</dl>
<dl>
<dd>Centre of scan is out of range.</dd>
</dl>
<dl>
<dt>MR_SCAN_FAIL_STATUS (-3)</dt>
</dl>
<dl>
<dd>Invalid status register.</dd>
</dl>
<dl>
<dt>MR_SCAN_FAIL_ADDRESS (-4)</dt>
</dl>
<dl>
<dd>Invalid address for results (0 counts as
invalid).</dd>
</dl>
<dl>
<dt>MR_SCAN_FAIL_NUMBER (-5)</dt>
</dl>
<dl>
<dd>Invalid number of results requested.</dd>
</dl>
<dl>
<dt>MR_SCAN_FAIL_IRPT (-6)</dt>
</dl>
<dl>
<dd>Not enough irpt to perform scan.</dd>
</dl>
<br>
<span style="font-weight: bold;">Bitfields</span><br>
<br>
The bitfield method registers allow the scanning process to filter out
certain processes. Each process has a binary signature determined by
its team: a process on team 0 has the signature 0b0001, a process on
team 1 has 0b0010, etc.<br>
<br>
In order for a process to be detected during a scan:<br>
<ol>
<li>At least one 1 bit in the process' signature must also be 1
in the WANT
bitfield;</li>
<li>All bits that are 1 in the NEED bitfield must also be 1 in
the
signature;</li>
<li>No bits that are 1 in the REJECT bitfield can be 1 in the
signature.</li>
</ol>
Currently the team of a process is the only value that can be filtered
in this way; this means that the NEED and REJECT bitfields are not
really useful yet. Future versions will have more values for filtering.<br>
<br>
The most obvious use of the WANT bitfield is to find any processes that
belong to another player. To do this, set up a bitmask like this:<br>
<br>
<code><span class="excode">scan_bitmask = 0b1111 ^
(1 &lt;&lt; get_team());</span></code><br>
This will give player 0 a 0b1110 bitmask, player 1 a 0b1101 bitmask,
etc.<br>
To find friendly processes only, use:<br>
<br>
<code><span class="excode">scan_bitmask =&nbsp;1
&lt;&lt; get_team();</span></code><br>
Example:<br>
<br>
<code><span class="excode">int scan_result [8] [2]; <span style="color: rgb(153, 153, 255);">// can hold up to 8
results of a scan</span><br>
int number_found;<br>
int scan_bitmask;<br>
scan_bitmask = 0b1111 ^ (1 &lt;&lt; get_team());<br>
<br>
number_found = call(METH_SCAN,<br>
&nbsp;MS_PR_SCAN_SCAN, <span style="color: rgb(153, 153, 255);">//
scan mode</span><br>
&nbsp;&amp;scan_result [0] [0], <span style="color: rgb(153, 153, 255);">// address of first
element of result array</span><br>
&nbsp;8, <span style="color: rgb(153, 153, 255);">//
number of targets to find</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
x offset of scan centre from process</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
y offset</span><br>
&nbsp;10000, <span style="color: rgb(153, 153, 255);">//
size of scan (in pixels). Maximum range is 400-900 ??; using a very
high value just results in the maximum being used</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
not used for scans by processes (see MT_CLOB_SCAN)</span><br>
&nbsp;scan_bitmask, <span style="color: rgb(153, 153, 255);">//
BITFIELD_WANT</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
need bitfield</span><br>
&nbsp;0); <span style="color: rgb(153, 153, 255);">//
reject bitfield</span></span></code><span class="excode"></span><br>
<br>
After this, the scan_result array will be filled with the x/y
coordinates (as offsets from the scanning process) of up to 8 nearby
enemy processes, sorted in increasing order of distance. The variable
number_found will hold the number of processes found.<br>
<br>
<span style="font-weight: bold;"><br>
Examine mode</span><br>
<br>
When called with the status MS_PR_SCAN_EXAMINE, this method gets
information about a single process at a particular location. It has the
same range as a scan. It will return 1 on success, 0 on failure.<br>
<br>
Only some of the method's registers are relevant to an EXAMINE
operation. These are:<br>
<dl>
<dt>MB_PR_SCAN_STATUS</dt>
</dl>
<dl>
<dd>Should be MS_PR_SCAN_EXAMINE.</dd>
</dl>
<dl>
<dt>MB_PR_SCAN_START_ADDRESS</dt>
</dl>
<dl>
<dd>The address of the first element of an array
large enough to hold the results.</dd>
</dl>
<dl>
<dt>MB_PR_SCAN_X1</dt>
</dl>
<dl>
<dd>The x offset (in pixels) of the examination from the
process' location.</dd>
</dl>
<dl>
<dt>MB_PR_SCAN_Y1</dt>
</dl>
<dl>
<dd>y offset.</dd>
</dl>
Currently the only information revealed by an examination is the
process' location (as an
offset from the examining process) and its speed. Future versions will
provide more.<br>
<br>
Example:<br>
<br>
<span class="excode"><code>int examine_result [4];<br>
int examine_success;<br>
int target_x, target_y, target_speed_x, target_speed_y;<br>
<br>
examine_success = call(METH_SCAN,<br>
&nbsp;MS_PR_SCAN_EXAMINE,<br>
&nbsp;&amp;examine_result [0],<br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
this is number of targets to find - not relevant for examine (is
ignored)</span><br>
&nbsp;200, <span style="color: rgb(153, 153, 255);">//
x offset from examining process</span><br>
&nbsp;0); <span style="color: rgb(153, 153, 255);">//
y offset</span><br>
<span style="color: rgb(153, 153, 255);">// other
registers are unused in this mode</span><br>
<br>
if (examine_success)<br>
{<br>
&nbsp;target_x = examine_result [0];<br>
&nbsp;target_y = examine_result [1];<br>
&nbsp;target_speed_x = examine_result [2];<br>
&nbsp;target_speed_y = examine_result [3];<br>
}</code><br>
</span><span class="excode"></span><br>
<span style="font-weight: bold;"><br>
Cost</span><br>
<br>
Calling
this method in scan mode costs 64 + (the maximum number of results
accepted * 2) + (scan_size / 8) irpt. So for a scan with a range of
1000 that accepts 4 results (no matter how many are actually found),
the cost would be 64 + (4 * 2) + (1000 / 8), or&nbsp;197.<br>
<br>
Calling this method in examine mode costs a flat rate of 48 irpt.<br>
<br>
<br>
<span class="method"><a name="Interrupt_generator:_MT_PR_IRPT"></a>Interrupt
generator: MT_PR_IRPT</span><br>
This method generates interrupts (irpts) that the process can use to
sustain itself and activate its other methods. It automatically generates a certain number of irpt each tick.<br>
<br>
Internal, automatic, single<br>
Cost: High<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>
0: capacity<br>
<br><br>
<span style="font-weight: bold;">Registers</span><br>
<dl>
<dt>MB_PR_IRPT_STATUS</dt>
</dl>
<dl>
<dd>Holds the method's status.</dd>
</dl><span style="font-weight: bold;"><br>Statuses</span><br>
<dl>
<dt>MS_PR_IRPT_SET</dt></dl><dl><dd>Calling the method with this status
sets it to generate the number of irpt in register 1. If this number is
too high, it will be set to maximum. It is set to maximum at process
creation, so you probably don't want to do anything to it (it's only
real purpose is to allow a process with an irpt method to self-destruct
by turning the method off, as a process with insufficient irpt takes
damage).</dd>
</dl>
<dl>
<dt>MS_PR_IRPT_MAX</dt>
</dl>
<dl>
<dd>Returns the number of irpt the method generates each tick.</dd>
</dl>The number of irpt that the method can generate each tick is 8 +
(4 * extension [0]).<br>
<br>
<br>
<span class="method"><a name="Data_allocator:_MT_PR_ALLOCATE"></a>Data
allocator: MT_PR_ALLOCATE</span><br>
This method allocates data when called. A process with this method is
immobile, and can neither move nor rotate.<br>
<br>
External, called, single<br>
Cost: Ultra<br>
Size 1 (method registers: 4)<br>
<br>
Extensions: none<br>
<br>
To use this method, call it (it can be called once per cycle, unless
another process with the same method is interfering with it). It does
not make any use of its registers.<br>
<br>
Processes
with this method should be at least 800 pixels away from each other, or
their efficiency will be reduced. A process can use the <a href="#Information:_MT_PR_INFO">MT_PR_INFO method</a>
to check efficiency at its current location (whether or not it has an
allocate method itself), and a client/observer can use the <a href="#Check_point:_MT_CLOB_POINT">MT_CLOB_POINT method</a>
to check efficiency at any location. Low efficiency prevents it from being called each cycle.<br>
<br>
It allocates 8 data when called,
and costs 32 irpt per data allocated.<br>
<br>
<br>
<span class="method"><a name="Information:_MT_PR_STD"></a>Standard:
MT_PR_STD</span><br>
This method provides various standard functions, most of the giving the process information about itself&nbsp;and a few of the
global parameters of the game. The compiler has a set of built-in
functions that simplify the use of this method and can do anything that
can be done by calling it directly (see <a href="#built-in_functions:_MT_PR_INFO_method">MT_PR_STD
built-in functions</a>).<br>
<br>
Internal, called<br>
Cost: Minimal<br>
Size 1 (method registers: 4)<br>
<br>
Extensions: none<br>
<br>
<span style="font-weight: bold;">Registers</span><br>
<dl>
<dt>MB_PR_STD_STATUS</dt>
</dl>
<dl>
<dd>When called, the method will return a value
determined by its status.</dd>
</dl>
<br>
<span style="font-weight: bold;">Statuses</span><br>
<dl>
<dt>MS_PR_STD_GET_X</dt>
</dl>
<dl>
<dd>The method returns the process' current x location
(in pixels).</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_Y</dt>
</dl>
<dl>
<dd>y location.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_ANGLE</dt>
</dl>
<dl>
<dd>Angle (in integer units, 0-8191).</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_SPEED_X</dt>
</dl>
<dl>
<dd>x component of velocity (multiplied by 16, to avoid underflow).</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_SPEED_Y</dt>
</dl>
<dl>
<dd>y component.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_TEAM</dt>
</dl>
<dl>
<dd>Which player controls this process (0 = player 1,
1 = player 2 etc.).</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_HP</dt>
</dl>
<dl>
<dd>Process' current hp.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_HP_MAX</dt>
</dl>
<dl>
<dd>Process' maximum hp.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_INSTR</dt>
</dl>
<dl>
<dd>Instructions left (imprecise as the call itself
uses instructions).</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_INSTR_MAX</dt>
</dl>
<dl>
<dd>Maximum number of instructions the process can have.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_IRPT</dt>
</dl>
<dl>
<dd>Irpt left.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_IRPT_MAX</dt>
</dl>
<dl>
<dd>Max irpt. If the process is connected with other processes, returns the shared total maximum.</dd>
</dl>
MS_PR_STD_GET_OWN_IRPT_MAX<br><dl>
<dd>Max irpt. Ignores other connected processes.</dd></dl>
<dl><dt>MS_PR_STD_GET_DATA</dt>
</dl>
<dl>
<dd>Data left.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_DATA_MAX</dt>
</dl>
<dl>
<dd>Max data. If the process is connected with other processes, returns the shared total maximum.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_OWN_DATA_MAX</dt>
</dl><dl><dd>Max data. Ignores other connected processes.</dd></dl>
<dl><dt>MS_PR_STD_GET_SPIN</dt>
</dl>
<dl>
<dd>Process' current spin, in integer units. If the
process is a group member, returns the group's spin.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_GR_X</dt>
</dl>
<dl>
<dd>Centre of mass of the process' group.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_GR_Y</dt>
</dl>
<dl>
<dd>Group y.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_GR_SPEED_X</dt>
</dl>
<dl>
<dd>x component of velocity of group's centre
(multiplied by 16).</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_GR_SPEED_Y</dt>
</dl>
<dl>
<dd>y component.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_GR_MEMBERS</dt>
</dl>
<dl>
<dd>Number of members of the group (returns 1 if
not a group member).</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_EX_COUNT</dt>
</dl>
<dl>
<dd>Ticks until process executes again (not so
useful, although its query counterpart may be useful).</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_WORLD_W</dt>
</dl>
<dl>
<dd>Width of game arena, in pixels.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_WORLD_H</dt>
</dl>
<dl>
<dd>Height.</dd>
</dl>
<dl>
<dt>MS_PR_STD_GET_EFFICIENCY</dt>
</dl>
<dl>
<dd>Efficiency that a data allocator would have
at the process' current location.</dd>
</dl>MS_PR_STD_GET_TIME
<dl><dd>Returns the elapsed time of the world (not just the process) in
ticks. Sets register 1 to the returned value and register 2 to that
value divided by 32,767 (to avoid overflow).</dd></dl><dl><dt>MS_PR_STD_GET_VERTICES</dt></dl><dl><dd>Returns the number of vertices the process has.</dd></dl><dl><dt>MS_PR_STD_GET_VX_ANGLE</dt></dl><dl><dd>Returns the angle of the vertex in register 1.</dd></dl><dl><dt>MS_PR_STD_GET_VX_DIST</dt></dl><dl><dd>Returns the distance to the vertex in register 1.</dd></dl><dl><dt>MS_PR_STD_GET_VX_ANGLE_PREV</dt></dl><dl><dd>Returns the previous angle of the vertex in register 1.</dd></dl><dl><dt>MS_PR_STD_GET_VX_ANGLE_NEXT</dt></dl><dl><dd>Returns the next angle of the vertex in register 1.</dd></dl><dl><dt>MS_PR_STD_GET_VX_ANGLE_MIN</dt></dl><dl><dd>Returns the minimum angle of the vertex in register 1.</dd></dl><dl><dt>MS_PR_STD_GET_VX_ANGLE_MAX</dt></dl><dl><dd>Returns the maximum angle of the vertex in register 1.</dd></dl><dl><dt>MS_PR_STD_ACTION</dt></dl><dl><dd>Assigns
the action in register 1 to the next console line printed by this
process, and all further lines printed by the process until the end of
its current execution cycle. If the user clicks on this line, the
action will be available
to the operator/observer/system program, which can use it to send
commands back to the process (this is how the prsc_cfactory.c process
accepts build commands).</dd></dl><dl><dd>See the end of this list of statuses for an example of how to use actions.</dd></dl><dl><dt>MS_PR_STD_WAIT</dt></dl><dl><dd>The process' next execution cycle will be delayed by the number of ticks in register 1 (to a maximum of 16 additional ticks).</dd></dl><dl><dt>MS_PR_STD_COLOUR</dt></dl><dl><dd>Changes
the colour of lines printed to a console. Register 1 is the colour
(uses a&nbsp;COL_* macro: colours are COL_DGREY, COL_LGREY, COL_WHITE,
COL_LBLUE, COL_DBLUE, COL_LRED, COL_DRED, COL_LGREEN, COL_DGREEN,
COL_LPURPLE, COL_DPURPLE).</dd></dl><dl><dt>MS_PR_STD_SET_COMMAND</dt></dl><dl><dd>Sets
the command register indicated by register 1 to the value in register
2. Processes need the MT_PR_COMMAND method to be able to read commands
back.</dd></dl><dl><dt>MS_PR_STD_COMMAND_BIT_0</dt></dl><dl><dd>Sets a particular bit of the contents of a command register to 0. Register 1 is the command register, register 2 is the bit.</dd></dl><dl><dt>MS_PR_STD_COMMAND_BIT_1</dt></dl><dl><dd>Sets a particular bit of the contents of a command register to 1. Register 1 is the command register, register 2 is the bit.</dd></dl><dl><dt>MS_PR_STD_PRINT_OUT</dt></dl><dl><dd>Sets
the process' print output to its standard output console (exactly which
console this is can be set by the operator/observer/system program).</dd></dl><dl><dt>MS_PR_STD_PRINT_OUT2</dt></dl><dl><dd>Sets the process' print output to its alternative output console (exactly
which console this is can be set by the operator/observer/system
program).</dd></dl><dl><dt>MS_PR_STD_PRINT_ERR</dt></dl><dl><dd>Sets the process' print output to its error output console (exactly
which console this is can be set by the operator/observer/system
program).</dd></dl><dl><dt>MS_PR_STD_TEMPLATE_NAME</dt></dl>
<dl><dd>Prints the name of the template (0 - 3) in register 1, as if the process had used the print command.</dd></dl><br>
Each call costs 1 irpt, except for GET_EFFICIENCY, which costs 32 irpt.<br><br><span style="font-weight: bold;"><br>How to use actions</span><br><br>
This method can be used to attach an <a href="Manual.html#Console_method:_actions">action</a>
to the next line of text that the
process prints using the print command, and all other lines that it
prints until this method is called again or execution is completed. If
the user clicks on a line with an action, an operator or observer
program is informed through its <a href="Manual.html#Console:_MT_OB_CONSOLE">MT_OB_CONSOLE
method</a> and can do something about it (such as focus on the
process, or give it a&nbsp;command).<br>
<br>
Processes themselves have no direct access to information about what
actions
the user has clicked on.<br>
<br>
All lines printed by processes have an action with value 0 attached by
default (the example observer/operator programs use this to focus on a
process if the user clicks on a line printed by the process).<br>
<br>Example:<br>
<br>
<code><span class="excode">call(METH_ACTION, 1);<br>
print("\n Click here to do A.");<br>
<br>
call(METH_ACTION, 2);<br>
print("\n Or here to do B.");<br>
<br>
<span style="color: rgb(153, 153, 255);">// If the user
clicks on either line, an action will be sent to the user's operator or
observer program<br>
<br style="color: rgb(153, 153, 255);">
</span>call(METH_ACTION, 0); // resets the action for any further
messages</span></code><span class="excode"></span><br>
<br>
<br>
<span class="method"><a name="Mathematics:_MT_PR_MATHS"></a>Mathematics:
MT_PR_MATHS</span><br>
This method provides maths functions more complicated than the simple
ones (add, subtract etc) that are available as basic bcode operations.
The compiler has a set of built-in functions that simplify the use of
this method and can do almost anything (save some possible
optimisations involving register re-use) that can be done by calling it
directly. For more information about this, and about the maths
functions generally, see <a href="#built-in_functions:_Maths">MT_PR_MATHS
built-in functions</a>.<br>
<br>
Internal, called<br>
Cost: Minimal<br>
Size 1 (method registers: 4)<br>
Extensions: none<br>
<br>
<br>
<span style="font-weight: bold;">Registers</span><br>
<dl>
<dt>MB_PR_MATHS_STATUS</dt>
</dl>
<dl>
<dd>Determines what function the method will perform
when called</dd>
</dl>
<dl>
<dt>MB_PR_MATHS_TERM1</dt>
</dl>
<dl>
<dt>MB_PR_MATHS_TERM2</dt>
</dl>
<dl>
<dt>MB_PR_MATHS_TERM3</dt>
</dl>
<dl>
<dd>These are the values the function will be performed
on.</dd>
</dl>
<br>
<span style="font-weight: bold;">Statuses</span><br>
<dl>
<dt>MS_PR_MATHS_NONE</dt>
</dl>
<dl>
<dd>Does nothing, returns 0. Is probably unnecessary.</dd>
</dl>
<dl>
<dt>MS_PR_MATHS_ATAN2</dt>
</dl>
<dl>
<dd>Returns atan2(term1, term2). Cost: 12 irpt.</dd>
</dl>
<dl>
<dt>MS_PR_MATHS_SIN</dt>
</dl>
<dl>
<dd>Returns sin(term1) * term2. Cost: 4 irpt.</dd>
</dl>
<dl>
<dt>MS_PR_MATHS_COS</dt>
</dl>
<dl>
<dd>Returns cos(term1) * term2. Cost: 4 irpt.</dd>
</dl>
<dl>
<dt>MS_PR_MATHS_HYPOT</dt>
</dl>
<dl>
<dd>Returns hypot(term1, term2). Cost: 8 irpt.</dd>
</dl>
<dl>
<dt>MS_PR_MATHS_TURN_DIR</dt>
</dl>
<dl>
<dd>Returns the direction (-1, 0 or 1) of the
shortest path from the angle term1 to the angle term2. Cost: 2 irpt.</dd>
</dl>
<dl>
<dt>MS_PR_MATHS_ANGLE_DIFF</dt>
</dl>
<dl>
<dd>Returns the magnitude of the difference between
angles term1 and term2. Cost: 2 irpt.</dd>
</dl>
<dl>
<dt>MS_PR_MATHS_ANGLE_DIFF_S</dt>
</dl>
<dl>
<dd>Same, but signed. Cost: 2 irpt.</dd>
</dl>
<dl>
<dt>MS_PR_MATHS_ABS</dt>
</dl>
<dl>
<dd>Returns abs(term1). Cost: 1 irpt.</dd>
</dl>
<dl>
<dt>MS_PR_MATHS_SQRT</dt>
</dl>
<dl>
<dd>Returns sqrt(term1). Cost: 8 irpt.</dd>
</dl>
<dl>
<dt>MS_PR_MATHS_POW</dt>
</dl>
<dl>
<dd>Returns pow(term1, term2). Cost: 4 irpt.</dd>
</dl>
When using this method, be careful not to use the return value of one
call to it as a parameter of another call (as the parameter call will
overwrite part of the other call). See built-in maths functions for
more on this.<br>
<br>
<br>
<span class="method"><a name="Designate:_MT_PR_DESIGNATE"></a>Designate:
MT_PR_DESIGNATE</span><br>
This method allows a process to track another process that is within
range, without having to use the scan method to find it each cycle. A
single process can have multiple designate methods if it needs to keep
track of multiple targets.<br>
<br>
Internal, called<br>
Cost: Minimal<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>
0: range<br>
<br>
<br>
<span style="font-weight: bold;">Registers</span><br>
<dl>
<dt>MB_PR_DESIGNATE_STATUS</dt>
</dl>
<dl>
<dd>Determines whether the method is acquiring a
target, or locating its previously acquired target.</dd>
</dl>
<dl>
<dt>MB_PR_DESIGNATE_X</dt>
</dl>
<dl>
<dd>x location of target (as an offset from calling
process).</dd>
</dl>
<dl>
<dt>MB_PR_DESIGNATE_Y</dt>
</dl>
<dl>
<dd>y location.</dd>
</dl>
<br>
<span style="font-weight: bold;">Statuses</span><br>
<dl>
<dt>MS_PR_DESIGNATE_LOCATE</dt>
</dl>
<dl>
<dd>Sets MB_PR_DESIGNATE_X/Y to the location of the
current acquired target, if it's in range. Returns 1 if the target is
found, 0 otherwise (which could mean that the target is out of range,
or no longer exists).<br></dd>
</dl><dl>
<dt>MS_PR_DESIGNATE_SPEED</dt></dl><dl><dd>Sets MB_PR_DESIGNATE_X/Y to the x and y speed&nbsp;of the
current&nbsp;acquired target, if it's in range.&nbsp;Returns 1 if the target is found, 0 otherwise.</dd></dl>
<dl><dt>MS_PR_DESIGNATE_ACQUIRE</dt>
</dl>
<dl>
<dd>Acquires target at MB_PR_DESIGNATE_X/Y offset
from process.</dd>
</dl>
<br>
To use this method, call it with status MS_PR_DESIGNATE_ACQUIRE and
with MB_PR_DESIGNATE_X/Y set to the offset of another process from the
calling process. It will return 1 if successful, 0 otherwise. Then in
future cycles the process can call the method with status
MS_PR_DESIGNATE_LOCATE to get the location of the target, and MS_PR_DESIGNATE_SPEED to get its speed.<br>
<br>
Calling with status MS_PR_DESIGNATE_LOCATE or _SPEED returns 1 if successful, and
0 if unsuccessful. A return value of 0 could mean the target is out of
range, or it could mean that the target no longer exists.<br>
<br>
The method's range is a square extending 900 pixels in each direction
from the process (plus an additional 300 pixels for each range
extension).<br>
<br>
Example of combining the scan and designate methods:<br>
<br>
<span class="excode"></span><code><span class="excode"></span></code><span class="excode"><code>int scan_return, designated,
scan_bitmask;<br>
int target_x, target_y;<br>
int scan_result [2];<br>
<br>
scan_bitmask = 0b1111 ^ (1 &lt;&lt; get_team());<br>
<br>
scan_return = call(METH_SCAN,<span style="color: rgb(153, 153, 255);">
// method's index</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MS_PR_SCAN_SCAN,<span style="color: rgb(153, 153, 255);"> // status register
(MB_PR_SCAN_STATUS) - tells the method to run scan</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;scan_result
[0], <span style="color: rgb(153, 153, 255);">// memory
address to put results of scan (MB_PR_SCAN_START_ADDRESS)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,
<span style="color: rgb(153, 153, 255);">// number of
targets to find (MB_PR_SCAN_NUMBER) - scanner will stop after finding 1</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,
<span style="color: rgb(153, 153, 255);">// x offset of
scan centre (MB_PR_SCAN_X1) - scan is centred on process</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,
<span style="color: rgb(153, 153, 255);">// y offset of
scan centre (MB_PR_SCAN_Y1) - scan is centred on process</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10000,
<span style="color: rgb(153, 153, 255);">// size of scan
(in pixels) (MB_PR_SCAN_SIZE) - very high value means maximum range</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,
<span style="color: rgb(153, 153, 255);">//
(MB_PR_SCAN_Y2) - not relevant to this type of scan</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scan_bitmask,
<span style="color: rgb(153, 153, 255);">// this bitmask
indicates which targets will be found (MB_PR_SCAN_BITFIELD_WANT)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,<span style="color: rgb(153, 153, 255);"> // bitmask for accepting
only certain targets (MB_PR_SCAN_BITFIELD_NEED) - not used here</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0);
<span style="color: rgb(153, 153, 255);">// bitmask for
rejecting certain targets (MB_PR_SCAN_BITFIELD_REJECT) - not used
here</span><br>
<br>
if (scan_return &gt; 0)<br>
{<br>
&nbsp; designated = call(METH_DESIGNATE,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MS_PR_DESIGNATE_ACQUIRE, <span style="color: rgb(153, 153, 255);">//
This mode saves a target</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
scan_result [0], <span style="color: rgb(153, 153, 255);">//
This is the location of the target as an x offset from the process</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
scan_result [1]); <span style="color: rgb(153, 153, 255);">//
Same for y</span><br>
<br>
<span style="color: rgb(153, 153, 255);">// The DESIGNATE
method returns 1 if it is successful (which should always be the case
here, but let's check anyway):</span><br>
&nbsp; if (designated == 1)<br>
&nbsp; {<br>
&nbsp;&nbsp; target_x = x + scan_result [0];<br>
&nbsp;&nbsp; target_y = y + scan_result [1];<br>
&nbsp; }<br>
}<br>
<br>
<span style="color: rgb(153, 153, 255);">// Later, if you
want to retrieve the location of the target:</span><br>
</code></span><span class="excode"><code><br>
designated = call(METH_DESIGNATE,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MS_PR_DESIGNATE_LOCATE);
<span style="color: rgb(153, 153, 255);">// This mode
saves a target</span><br>
<br>
target_x = get(METH_DESIGNATE,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;MB_PR_DESIGNATE_X);<br>
</code></span><span class="excode"><code>target_y
= get(METH_DESIGNATE,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;MB_PR_DESIGNATE_Y);<br>
<br>
</code></span><span style="font-family: monospace;"><br>
</span><br>
<br>
<span class="method"><a name="Link:_MT_PR_LINK"></a>Link:
MT_PR_LINK</span><br>
This method allows processes to connect to each other directly. If a
process creates another process using the <a href="#New:_MT_PR_NEW">MT_PR_NEW</a>
or <a href="#New_sub:_MT_PR_NEW_SUB">MT_PR_NEW_SUB</a>
method, and if each process has an MT_PR_LINK method at the vertex that
meets the other process, and if the MB_PR_NEW_LINK register is set to
1, the processes will be connected. A group of processes connected in
this way can have as many as 16 members.<br>
<br>
There is not (currently) any way to have two existing separate
processes join together.<br>
<br>
External, called<br>
Cost: Minimal<br>
Size 1 (method registers: 4)<br>
<br>
Extensions: none<br>
<br>
<br>
<span style="font-weight: bold;">Registers</span>
<dl>
<dt>MB_PR_LINK_STATUS</dt>
</dl>
<dl>
<dd>Determines what the method does when called.</dd>
</dl>
<dl>
<dt>MB_PR_LINK_VALUE1</dt>
</dl>
<dl>
<dd>The purpose of this register depends on its status
when called.</dd>
</dl>
<dl>
<dt>MB_PR_LINK_VALUE2</dt>
</dl>
<dl>
<dd>Same.</dd>
</dl>
<dl>
<dt>MB_PR_LINK_MESSAGE_ADDRESS</dt>
</dl>
<dl>
<dd>This register holds a memory address to
which messages received through the connection will be stored.</dd>
</dl>
<br>
<span style="font-weight: bold;">Statuses</span><br>
<dl>
<dt>MS_PR_LINK_EXISTS</dt>
</dl>
<dl>
<dd>Returns 1 if there is something connected to this
method, 0 if nothing connected.</dd>
</dl>
<dl>
<dt>MS_PR_LINK_MESSAGE</dt>
</dl>
<dl>
<dd>Sends the two value registers as a message to the
process on the other side of the connection.</dd>
</dl>
<dl>
<dt>MS_PR_LINK_RECEIVED</dt>
</dl>
<dl>
<dd>Returns the number of messages received from the
other process since the last cycle.</dd>
</dl>
<dl>
<dt>MS_PR_LINK_SEND_IRPT</dt>
</dl>
<dl>
<dd>Dends
an amount of irpt (determined by value1)
through the connection. If there is limited space in the other process'
irpt buffer, the amount sent will be reduced accordingly. There is
overhead of 24 irpt for calling this, but no limit on the amount sent.</dd>
</dl>
<dl>
<dt>MS_PR_LINK_SEND_DATA</dt>
</dl>
<dl>
<dd>Sends data.&nbsp;There is overhead of 24 irpt for
calling this, but no limit on the amount sent.</dd>
</dl>
<dl>
<dt>MS_PR_LINK_NEXT_EXECUTION</dt>
</dl>
<dl>
<dd>Returns the number of ticks before the
connected process will execute.</dd>
</dl>
<dl>
<dt>MS_PR_LINK_DISCONNECT</dt>
</dl>
<dl>
<dd>Lets go.</dd>
</dl>
<br>
The method can receive up to&nbsp;LINK_MESSAGES_MAX messages
(currently 8),
each&nbsp;LINK_MESSAGE_SIZE long (currently 2).<br>
<br>
An example of sending and receiving messages:<br>
<br>
<code><span class="excode"><span style="color: rgb(153, 153, 255);">// the sending process
does this:</span><br>
call(METH_LINK, MS_PR_LINK_MESSAGE, 100, 200);<br>
<br>
<span style="color: rgb(153, 153, 255);">// the receiving
process does this:</span><br>
int link_message [LINK_MESSAGES_MAX] [LINK_MESSAGE_SIZE];<br>
int number_of_messages;<br>
<br>
put(METH_LINK, MB_PR_LINK_MESSAGE_ADDRESS, &amp;link_message [0]
[0]); <span style="color: rgb(153, 153, 255);">// only
need to do this once, at process initialisation</span><br>
<br>
number_of_messages = call(METH_LINK, MS_PR_LINK_RECEIVED); <span style="color: rgb(153, 153, 255);">// this call will return 1 because the other process sent 1 message</span><br>
<br>
if (number_of_messages &gt; 0)<br>
{<br>
<span style="color: rgb(153, 153, 255);"><br>&nbsp;// the sending process' call above will have set link_message [0] [0] to 100 and link_message [0] [1] to 200</span><br>
<span style="color: rgb(153, 153, 255);">&nbsp;// so here we can do
something with the messages...</span><br>
<br>
}</span><span class="excode"></span></code><br>
<br>
<br>
<span class="method"><a name="Restore:_MT_PR_RESTORE"></a>Restore:
MT_PR_RESTORE</span><br>
This method allows processes to repair themselves.<br>
<br>
Internal, called<br>
Cost: High<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>
0: rate<br>
<br>
<br>
<span style="font-weight: bold;">Registers</span><br>
<dl>
<dt>MB_PR_RESTORE_NUMBER</dt>
</dl>
<dl>
<dd>The number of hp the method will try to restore
when called.</dd>
</dl>
Example:<br>
<br>
<code><span class="excode">call(METH_RESTORE, 4); <span style="color: rgb(153, 153, 255);">// tries to restore 4 hp.</span></span></code><br>
The method can restore 1 hp per call, plus 1 for each rate extension.
It can be called once per cycle. Restoring costs 128 irpt per hp
restored, so it is not cheap.<br>
<br>
<br>
<span class="method"><a name="Redundancy:_MT_PR_REDUNDANCY"></a>Redundancy:
MT_PR_REDUNDANCY</span><br>
This method increases the number of hp a process has.<br>
<br>
Internal, not called, single<br>
Cost: Minimal + special<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>
0: extra<br>
<br>
Registers: None<br>
<br>
If a process has this method, its hp is increased by 40% (plus an
additional 20% for each extension). The process' mass (and therefore
also its data cost) is increased
by the same proportion.<br>
<br>
<br>
<span class="method"><a name="Broadcast:_MT_PR_BROADCAST"></a>Broadcast:
MT_PR_BROADCAST</span><br>
This method allows a process to communicate with other processes that
have the <a href="#Listen:_MT_PR_LISTEN">MT_PR_LISTEN
method</a>.<br>
<br>
External, called<br>
Cost: Minimal<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>
0: range<br>
<br>
<span style="font-weight: bold;">Registers</span>
<dl>
<dt>MB_PR_BROADCAST_POWER</dt>
</dl>
<dl>
<dd>This is the range of the broadcast, in pixels
(the range is a square extending this number of pixels in each
direction). If this register is set too high, the maximum range will be
used.</dd>
</dl>
<dl>
<dt>MB_PR_BROADCAST_ID</dt>
</dl>
<dl>
<dd>This holds a bitfield message ID that listening
processes can use to screen incoming messages.</dd>
</dl>
<dl>
<dt>MB_PR_BROADCAST_VALUE1</dt>
</dl>
<dl>
<dd>This is the first value of the message.</dd>
</dl>
<dl>
<dt>MB_PR_BROADCAST_VALUE2</dt>
</dl>
<dl>
<dd>Second value (each message is 2 ints long).</dd>
</dl>
Example:<br>
<br>
<br class="excode">
<code><span class="excode">call(METH_BROADCAST,
1000, 0b101, 5, 10); <span style="color: rgb(153, 153, 255);">//
sends the message (5, 10)
to other processes within 1000 pixels (orthogonally), with a bitfield
message ID of 0b101.</span></span></code><br>
The maximum range of a broadcast is 600 pixels, plus 300 for each range
extension. The cost of sending a broadcast is 32 irpt plus the
broadcast's power / 32.<br>
<br>
<br>
<span class="method"><a name="Listen:_MT_PR_LISTEN"></a>Listen:
MT_PR_LISTEN</span><br>
This method receives and stores messages sent by other processes using
the <a href="#Broadcast:_MT_PR_BROADCAST">broadcast method</a>.
It can only hear messages sent by processes
controlled by the same player.<br>
<br>
Internal, called, automatic<br>
Cost: Minimal<br>
Size 1 (method registers: 4)<br>
<br>
Extensions: none<br>
<br>
<br>
<span style="font-weight: bold;">Registers</span><br>
<dl>
<dt>MB_PR_LISTEN_ID_WANT</dt>
</dl>
<dl>
<dd>A&nbsp;bitfield. At least one bit of the value in this
register must be 1 in a broadcast's message ID for the message to be
received. Set this to 0 to receive no messages.</dd>
</dl>
<dl>
<dt>MB_PR_LISTEN_ID_NEED</dt>
</dl>
<dl>
<dd>All bits that are 1 in this value must be 1 in a
broadcast's message ID for the message to be received.</dd>
</dl>
<dl>
<dt>MB_PR_LISTEN_ID_REJECT</dt>
</dl>
<dl>
<dd>No bits that are 1 in this value can be 1 in a
broadcast's message ID for the message to be received.</dd>
</dl>
<dl>
<dt>MB_PR_LISTEN_ADDRESS</dt>
</dl>
<dl>
<dd>The address that received messages will be
recorded to. If 0, no messages will be recorded.</dd>
</dl>
A listen method can receive up to LISTEN_MESSAGES messages (currently
8) between cycles, and each message is LISTEN_MESSAGE_SIZE (currently
5) ints long. When called, it returns the number of messages received
since the previous cycle.<br>
<br>
The structure of a message is:<br>
<dl>
<dt>LISTEN_RECORD_ID</dt>
</dl>
<dl>
<dd>The message ID bitfield.</dd>
</dl>
<dl>
<dt>LISTEN_RECORD_VALUE1</dt>
</dl>
<dl>
<dd>The first value of the message.</dd>
</dl>
<dl>
<dt>LISTEN_RECORD_VALUE2</dt>
</dl>
<dl>
<dd>Second value.</dd>
</dl>
<dl>
<dt>LISTEN_RECORD_SOURCE_X</dt>
</dl>
<dl>
<dd>The location of the message's source when the
message was sent, as an x offset from the listening process.</dd>
</dl>
<dl>
<dt>LISTEN_RECORD_SOURCE_Y</dt>
</dl>
<dl>
<dd>y&nbsp;offset.</dd>
</dl>
Example:<br>
<br>
<br class="excode">
<code><span class="excode">int messages
[LISTEN_MESSAGES] [LISTEN_MESSAGE_SIZE];<br>
<br>
int messages_received, message_source_x_offset, message_source_y_offset;<br>
<br>
put(METH_LISTEN, MB_PR_LISTEN_ADDRESS, &amp;messages [0] [0]); <span style="color: rgb(153, 153, 255);">//
only needs to be done once, at process initialisation<br>
<br>
</span>put(METH_LISTEN, MB_PR_LISTEN_WANT, 0xFFFF); <span style="color: rgb(153, 153, 255);">// receive all messages -
this also only needs to be done once, at initialisation<br>
<br>
// Now check for messages received:<br>
</span>messages_received = call(METH_LISTEN);<br>
<br>
if (messages_received &gt; 0)<br>
{<br>
<span style="color: rgb(153, 153, 255);">&nbsp;// find
the location of the process that sent the first message
received: </span><br>
&nbsp;message_source_x_offset = messages [0]
[LISTEN_RECORD_SOURCE_X]; <br>
&nbsp;message_source_y_offset = messages [0]
[LISTEN_RECORD_SOURCE_Y];<br>
}</span></code><br>
<br>
<span class="method"><a name="Yield:_MT_PR_YIELD"></a>Yield:
MT_PR_YIELD</span><br>
This method allows a process to transmit irpt and data to another
nearby process. It transfers much more slowly than the <a href="#Link:_MT_PR_LINK">MT_PR_LINK method</a>, but
does not require a direct connection.<br>
<br>
External, called<br>
Cost: Medium<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>
0: range<br>
1: rate<br>
<br>
<span style="font-weight: bold;"><br>
Registers</span><br>
<dl>
<dt>MB_PR_YIELD_IRPT</dt>
</dl>
<dl>
<dd>When called, the method tries to transfer this much
irpt to the target process.</dd>
</dl>
<dl>
<dt>MB_PR_YIELD_DATA</dt>
</dl>
<dl>
<dd>Same, for data.</dd>
</dl>
<dl>
<dt>MB_PR_YIELD_X</dt>
</dl>
<dl>
<dd>This is the location of the target process, as an x
offset from the yielding process.</dd>
</dl>
<dl>
<dt>MB_PR_YIELD_Y</dt>
</dl>
<dl>
<dd>y offset.</dd>
</dl>
<br>
<span style="font-weight: bold;">Return values</span><br>
<br>
The method returns one of the following values:<br>
<dl>
<dt>MR_YIELD_SUCCESS</dt>
</dl>
<dl>
<dd>Success.</dd>
</dl>
<dl>
<dt>MR_YIELD_FAIL_ALREADY</dt>
</dl>
<dl>
<dd>The method has already been called this cycle.</dd>
</dl>
<dl>
<dt>MR_YIELD_FAIL_SETTINGS</dt>
</dl>
<dl>
<dd>One of the method's registers contains an
invalid number.</dd>
</dl>
<dl>
<dt>MR_YIELD_FAIL_IRPT</dt>
</dl>
<dl>
<dd>The process doesn't have enough irpt.</dd>
</dl>
<dl>
<dt>MR_YIELD_FAIL_DATA</dt>
</dl>
<dl>
<dd>The process doesn't have enough data.</dd>
</dl>
<dl>
<dt>MR_YIELD_FAIL_TARGET</dt>
</dl>
<dl>
<dd>Nothing was found at the target location.</dd>
</dl>
<dl>
<dt>MR_YIELD_FAIL_FULL</dt>
</dl>
<dl>
<dd>The target process had no space in its irpt or data
buffer to receive anything.</dd>
</dl>
<dl>
<dt>MR_YIELD_FAIL_RANGE</dt>
</dl>
<dl>
<dd>The specified x/y offsets are out of range.</dd>
</dl>
Trying to send more irpt or data than the target can receive just
results in a lesser amount being transferred (unless nothing can be
transferred at all, in which the call fails).<br>
<br>
The method has a range of 500 pixels (orthogonal square) plus 300 per
range extension, and
can transfer at a rate of 255 irpt plus 127 per rate extension, and 4
data plus 4 per rate extension. Calling it has an overhead of 32 irpt.<br>
<br>
<br>
<span class="method"><a name="Storage:_MT_PR_STORAGE"></a>Storage:
MT_PR_STORAGE</span><br>
This method increases the amount of data a process can store.<br>
<br>
Internal, not called<br>
Cost: Medium<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>
0: capacity<br>
<br>
Registers: none<br>
<br>
Increases the maximum data storage by 40% plus 20% for each capacity
extension.<br>
<br>
<br>
<span class="method"><a name="Static:_MT_PR_STATIC"></a>Static:
MT_PR_STATIC</span><br>
This method makes a process immobile, like an <a href="#Data_allocator:_MT_PR_ALLOCATE">allocate method</a>.
It isn't particularly useful, but it's there if you need it.<br>
<br>
Internal, not called<br>
Cost: Minimal<br>
Size 1 (method registers: 4)<br>
<br>
Registers: none<br>
<br>
<br>
<span class="method"><a name="Command_process:_MT_PR_COMMAND"></a>Command
(process): MT_PR_COMMAND</span><br>
This method allows a process to receive commands from its player's client
program. You can use the&nbsp;<a href="#Command_process:_MT_PR_COMMAND">get_command() and get_command_bit() built-in functions</a> to
call this method easily.<br><br>Each process has 16 command registers, each of which can be read and
written to by both the process and the client. Command registers are
initialised to zero on process creation, but retain their
values between executions.<br><br>This method is not needed to write to command registers; the MT_PR_STD method can do this.<br><br>
Internal, called<br>
Cost: Minimal<br>
Size 1 (method registers: 4)<br>
<br>
Extensions: none<br>
<br>
<span style="font-weight: bold;"><br>
Registers</span><br>
<dl>
<dt>MB_PR_COMMAND_STATUS</dt>
</dl>
<dl>
<dd>Read or write.</dd>
</dl>
<dl>
<dt>MB_PR_COMMAND_INDEX</dt>
</dl>
<dl>
<dd>Which command register is being read from.</dd>
</dl>
<dl>
<dt>MB_PR_COMMAND_BIT</dt>
</dl>
<dl>
<dd>If reading a single bit, this is the bit.</dd>
</dl>
<span style="font-weight: bold;"><br>
Statuses</span><br>
<dl>
<dt>MS_PR_COMMAND_READ</dt>
</dl>
<dl>
<dd>Calling with this status returns the value of the
command register in MB_PR_COMMAND_INDEX.</dd>
</dl>
<dl>
<dt>MS_PR_COMMAND_BIT</dt>
</dl>
<dl>
<dd>Calling with this status returns the value (1 or 0) of a single bit
(indicated by MB_PR_COMMAND_BIT) in&nbsp;command
register&nbsp;MB_PR_COMMAND_INDEX.</dd>
</dl>
<br>
<br>
<span class="method"><a name="Virtual:_MT_PR_VIRTUAL"></a>Virtual interface: MT_PR_VIRTUAL</span><br>
This method provides a buffer that absorbs&nbsp;damage that would otherwise be inflicted on a process. It
can greatly increase the process' durability, but it is expensive and having it active costs a lot of irpt.<br><br>
Internal, called, single<br>
Cost: Ultra<br>
Size 1 (method registers: 4)<br>
<br>
Extensions:<br>0: capacity<br>1: charge rate<br>
<br>Maximum capacity is 96 (plus 32 for each capacity extension).<br><br>Costs an additional 64 irpt (plus 32 for each extension) each cycle while active.<br>
<span style="font-weight: bold;"><br>Registers<br></span><dl><dt>MB_PR_VIRTUAL_STATUS</dt></dl><dl><dd>Status register. Affects what the method does when called.</dd></dl><dl><dt>MB_PR_VIRTUAL_VALUE</dt></dl><dl><dd>When calling the method with the&nbsp;MS_PR_VIRTUAL_CHARGE status, this register determines how much charge is attempted.</dd></dl><dl><dt>MB_PR_VIRTUAL_CURRENT</dt></dl><dl><dd>This register holds the current strength of the method. Changing it doesn't do anything.</dd></dl><dl><dt>MB_PR_VIRTUAL_MAX</dt></dl><dl><dd>This register holds the maximum strength of the method. Changing it doesn't do anything.</dd></dl><span style="font-weight: bold;">Statuses<br></span><br>MS_PR_VIRTUAL_CHARGE
<dl><dd>When called, tries to charge up the method by the amount in
register 1. The maximum amount it can be charged by is 4 (plus 3 for
each charge rate extension), and it&nbsp;can&nbsp;be charged only once
each execution cycle. There is no need&nbsp;to check whether the method
is fully charged, as any overcharge is ignored.</dd></dl><dl><dd>After a virtual interface is broken by damage, it cannot be charged for a short period (96 ticks).<br></dd></dl>MS_PR_VIRTUAL_GET_STATE<br><dl><dd>Returns
-1 if the method is active, 0 if it is inactive but can be charged, or,
if it has been broken and cannot be charged yet, the number of ticks
before it can be charged.<br></dd></dl><dl><dt>MS_PR_VIRTUAL_GET_MAX</dt></dl><dl><dd>Returns the maximum capacity of the method.<br></dd></dl><dl><dt>MS_PR_VIRTUAL_DISABLE</dt></dl><dl><dd>Turns the method off, losing all charge (but not preventing recharging for any period of time).</dd></dl><span style="font-weight: bold;"><br></span>
<h2><a class="mozTocH2" name="mozTocId277936"></a><a name="Client_methods_CL"></a> 6.2 Client methods (CL)</h2>
These methods can be used by
operator, delegate and system programs.<br>
<br>
<span class="method"><a name="Command_client:_MT_CL_COMMAND_GIVE"></a>Command
(client): MT_CL_COMMAND_GIVE</span><br>
This method is the other side of the MT_PR_COMMAND method. It allows a
client program to communicate with all processes it controls by
writing to&nbsp;their command registers (the MT_CLOB_COMMAND_REC method allows clients and observers to read command registers).<br>
<br>
Size 1 (method registers: 4)<br>
<br>
<span style="font-weight: bold;"><br>
Registers</span><br>
<dl>
<dt>MB_PR_COMMAND_STATUS</dt>
</dl>
<dl>
<dd>Read or write.</dd>
</dl>
<dl>
<dt>MB_PR_COMMAND_PR_INDEX</dt>
</dl>
<dl>
<dd>Which process is being commanded.</dd>
</dl>
<dl>
<dt>MB_PR_COMMAND_CMD_INDEX</dt>
</dl>
<dl>
<dd>Which command register is being used.</dd>
</dl>
<dl>
<dt>MB_PR_COMMAND_VALUE</dt>
</dl>
<dl>
<dd>If writing to a register, this is the value written.</dd>
</dl>
<span style="font-weight: bold;"><br>
Statuses</span><br>
<dl>
<dt>MS_CL_COMMAND_VALUE</dt>
</dl>
<dl>
<dd>Sets the command register in MB_PR_COMMAND_CMD_INDEX of the process in MB_PR_COMMAND_PR_INDEX to MB_PR_COMMAND_VALUE.</dd>
</dl>
<dl>
<dt>MS_CL_COMMAND_BIT_0</dt>
</dl>
<dl>
<dd>Like MS_CL_COMMAND_VALUE, but MB_PR_COMMAND_VALUE indicates a bit of the register that is to be set to 0.</dd>
</dl>MS_CL_COMMAND_BIT_1
<dl><dd>Like MS_CL_COMMAND_BIT_0, but sets the bit to 1.<br></dd></dl>
You can use the <a href="#built-in_functions:_MT_CL_COMMAND">command(),&nbsp;command_bit_0(1) and command_bit_1() built-in functions</a> to
call this method easily.<br>
<br>
<br>
<span class="method"><a name="Template:_MT_CL_TEMPLATE"></a>Template:
MT_CL_TEMPLATE</span><br>
This
method copies code from the client program to a process template (if
the system program allows process templates to be modified). It works a
lot like the <a href="#Template:_MT_SY_TEMPLATE">MT_SY_TEMPLATE
method</a>, except that it can only copy to the
player's process templates (so the template index is just a number from
0 to 3).<br>
<br>
Size 1 (method registers: 4)<br>
<br>
<span style="font-weight: bold;"><br>
Registers</span><br>
<dl>
<dt>MB_CL_TEMPLATE_INDEX</dt>
</dl>
<dl>
<dd>This is the number of the process template (0 to 3).</dd>
</dl>
<dl>
<dt>MB_CL_TEMPLATE_START</dt>
</dl>
<dl>
<dd>This is the start address, in the client's bcode, of the
code to copy.</dd>
</dl>
<dl>
<dt>MB_CL_TEMPLATE_END</dt>
</dl>
<dl>
<dd>This is the end address.</dd>
</dl>
<dl>
<dt>MB_CL_TEMPLATE_NAME</dt>
</dl>
<dl>
<dd>This is the address of a null-terminated string to be used
as the name of the template. If 0, the template is not given a name.</dd>
</dl>
<br>
<h2><a class="mozTocH2" name="mozTocId6563"></a><a name="ClientObserver_methods_CLOB"></a> 6.3
Client/Observer methods (CLOB)</h2>
These methods can be used by clients (operators and delegates),
observers and system programs.<br>
<br>
<br>
<span class="method"><a name="Check_point:_MT_CLOB_POINT"></a>Check point:
MT_CLOB_POINT</span><br>
Allows a client/observer to find what's at a particular location.<br>
<br>
Size 1 (method registers: 4)<br>
<br>
<span style="font-weight: bold;"><br>
Statuses</span><br>
<dl>
<dt>MS_CLOB_POINT_EXACT</dt>
</dl>
<dl>
<dd>This status followed by x,y coordinates returns
the index of the process at that location (with more or less pixel
accuracy), or -1 if no process found.</dd>
</dl>
<dl>
<dt>MS_CLOB_POINT_FUZZY</dt>
</dl>
<dl>
<dd>Similar to EXACT, but checks a small area around
the target coordinates as well and returns the index of the closest process. May be useful for things like checking
whether the user has clicked on a process.</dd>
</dl>
<dl>
<dt>MS_CLOB_POINT_ALLOC_EFFIC</dt>
</dl>
<dl>
<dd>Returns the allocator efficiency (0-100)
that a process with an <a href="#Data_allocator:_MT_PR_ALLOCATE">allocator
method</a> would have at a particular location.</dd>
</dl>
Example:<br>
<br>
<code><span class="excode">a = call(METH_POINT,
MS_CLOB_POINT_EXACT, 1000, 3000); <span style="color: rgb(153, 153, 255);">// returns index
of process at 1000,3000</span></span></code><br>
<br>
<span class="method"><a name="Query:_MT_CLOB_QUERY"></a>Query:
MT_CLOB_QUERY</span><br>
Allows a client/observer to run the equivalent of an <a href="#Information:_MT_PR_INFO">MT_PR_INFO method</a>
call
for a specified process. Uses the same MS_PR_INFO_* statuses as the
INFO method. Can be called on processes controlled by other players.
Returns -1 if a process doesn't exist, unless it was destroyed in the
last few ticks in which case it returns -2.<br>
<br>
Size 1 (method registers: 4)<br>
<br>
Example:<br>
<br>
<code><span class="excode">x = call(METH_QUERY,
MS_PR_INFO_GET_X, 20); <span style="color: rgb(153, 153, 255);">//
returns x coordinate of
process 20</span></span></code><br>
The <a href="#built-in_functions:_MT_CLOB_QUERY">query_*()
built-in functions</a> make it easy to use this method.<br>
<br>
<br>
<span class="method"><a name="Scan_clob:_MT_CLOB_SCAN"></a>Scan
(clob): MT_CLOB_SCAN</span><br>
Allows a client/observer to scan an area of the world, a bit like a
process' scan using the <a href="#Scan:_MT_PR_SCAN">MT_PR_SCAN
method</a>.<br>
<br>
Size 2 (method registers: 8)<br>
<br>
<span style="font-weight: bold;"><br>
Statuses</span><br>
<dl>
<dt>MS_CLOB_SCAN_SCAN</dt>
</dl>
<dl>
<dd>This status works much like the MT_PR_SCAN scan, and
uses the same <a href="#Scan_method:_Registers">MB_*
macros</a>. The differences are:</dd>
</dl>
<ol style="margin-left: 40px;">
<li>The MB_PR_SCAN_X1 and Y1 values are absolute values rather
than
offsets. The centre of the scan can be anywhere in the game area.</li>
<li>The scan's maximum size is 1200 (as CLOB methods don't have
extensions).</li>
</ol>
MS_CLOB_SCAN_RECTANGLE
<dl>
</dl>
<dl>
<dd>This status performs a scan over a rectangle
with specified corners, rather than a square. Its results are ordered
roughly from left to right then top to bottom, rather than from the
centre of
the scan. Also:</dd>
</dl>
<ol style="margin-left: 40px;">
<li>The MB_PR_SCAN_X1 and Y1 values are the coordinates of the
top left
of the rectangle.</li>
<li>The MB_PR_SCAN_SIZE value is the x coordinate of the bottom
right,
and the MB_PR_SIZE2 value is the y coordinate of the bottom right.</li>
<li>The maximum size of the scan is 4096x4096 pixels. If it is
larger, it
will be shrunk from the right and bottom.</li>
</ol>
MS_CLOB_SCAN_EXAMINE
<dl>
<dd>Like the MS_PR_SCAN_EXAMINE call, but the
MB_PR_SCAN_X1 and Y1 values are absolute values rather than offsets.</dd>
</dl>
MS_CLOB_SCAN_SCAN_INDEX
<dl>
<dd>This works in the same way as
MS_CLOB_SCAN_SCAN, but the results array is a list of process indices
rather than a list of coordinates.</dd>
</dl>
MS_CLOB_SCAN_RECTANGLE_INDEX
<dl>
<dd>The rectangular version of
MS_CLOB_SCAN_SCAN_INDEX.</dd>
</dl>
All calls return the number of processes found if successful, and an
<a href="#Scan:_Return_values">MR_SCAN_FAIL_*</a>
value if unsuccessful.<br>
<br>
<br>
<span class="method"><a name="Maths_clob:_MT_CLOB_MATHS"></a>Maths
(clob): MT_CLOB_MATHS</span><br>
This works just like <a href="#Mathematics:_MT_PR_MATHS">MT_PR_MATHS</a>,
and uses the MS_PR_MATHS_* status
values and <a href="#built-in_functions:_Maths">built-in
functions</a>.<br>
<br>
Size 1 (method registers: 4)<br>
<br>
<span class="method"><a name="Standard_CLOB:_MT_CLOB_STD"></a>Standard client/observer method:
MT_CLOB_STD</span><br>
Gives a client/observer various basic functions, such as functions returning pieces of information about the game
parameters or&nbsp;about the client/observer itself. The <a href="#built-in_functions:_MTYPE_CLOB_WORLD">world_*()
built-in functions</a> can be used instead of some of these method calls.<br>
<br>
Size 1 (method registers: 4)<br>
<br>
<span style="font-weight: bold;"><br>
Statuses</span><br>
<dl>
<dt>MS_CLOB_STD_WORLD_SIZE_X</dt>
</dl>
<dl>
<dd>Returns the width of the game area, in pixels.</dd>
</dl>
<dl>
<dt>MS_CLOB_STD_WORLD_SIZE_Y</dt>
</dl>
<dl>
<dd>Same, for height.</dd>
</dl>
<dl>
<dt>MS_CLOB_STD_WORLD_PROCS</dt>
</dl>
<dl>
<dd>The maximum number of processes that can exist.</dd>
</dl>
<dl>
<dt>MS_CLOB_STD_WORLD_TEAM</dt>
</dl>
<dl>
<dd>The player index number of the client (-1 for
observers).</dd>
</dl>
<dl>
<dt>MS_CLOB_STD_WORLD_TEAMS</dt>
</dl>
<dl>
<dd>How many players there are.</dd>
</dl>
<dl>
<dt>MS_CLOB_STD_WORLD_TEAM_SIZE</dt>
</dl>
<dl>
<dd>Actual number of processes for team indicated
by register 1.</dd>
</dl>
<dl>
<dt>MS_CLOB_STD_WORLD_PROCS_EACH</dt>
</dl>
<dl>
<dd>Maximum number of processes for each team.</dd>
</dl>
<dl>
<dt>MS_CLOB_STD_WORLD_FIRST_PROC</dt>
</dl>
<dl>
<dd>First process index for team indicated by
register 1 (e.g. if each team can have 100 processes, calling this for
team 2 will return 200).</dd>
</dl>
<dl>
<dt>MS_CLOB_STD_WORLD_LAST_PROC</dt>
</dl>
<dl>
<dd>Last process index (e.g. if each team can have
100 processes, calling this for team 2 will return 299).</dd>
</dl>
<dl>
<dt>MS_CLOB_STD_WORLD_INSTR_LEFT</dt>
</dl>
<dl>
<dd>How many instructions the client/observer has
left.</dd>
</dl>MS_CLOB_STD_WORLD_TIME
<dl><dd>Returns how many ticks have elapsed in the game. This is likely
to overflow fairly quickly, so after the method is called with this
status, register 1 holds the time divided by 32767 (also, register
holds the time % 32767).</dd></dl>MS_CLOB_STD_TEMPLATE_NAME<br><dl><dd>Prints the name of a process template to a console (as if it was being printed with the print() function).</dd></dl><dl><dd>If used by a client or operator program,&nbsp;register 1 holds the index (0 to 3) of the process template.</dd></dl><dl><dd>If
used by an observer or system program, register 1 holds the index of
the player who the template belongs to, and register 2 holds the
template's index.</dd></dl><br>
<span class="method"><a name="Command_rec:_MT_CLOB_COMMAND_REC"></a>Command receive: MT_CLOB_COMMAND_REC</span><br>
This method allows client and observer programs to read process'
command registers. If used by a client, only processes controlled by
the client can be read.<br><br>
Size 1 (method registers: 4)<br>
<br>
<span style="font-weight: bold;"><br></span><span style="font-weight: bold;">Statuses</span><br>
<dl><dt>MS_CLOB_COMMAND_VALUE</dt></dl>
<dl><dd>Register 1 holds the process index, and register 2 holds the index of the command register.</dd></dl>
<dl><dt>MS_CLOB_COMMAND_BIT</dt></dl>
<dl><dd>Register 1 holds the process index, register 2 holds the index
of the command register and register 3 indicates which bit is being
read. The method returns 0 or 1.</dd></dl>You can use the&nbsp;<a href="Manual.html#built-in_functions:_MT_CLOB_COMMAND">check_command() and check_command_bit(1) built-in functions</a> to
call this method easily.<br>
<br>
<h2><a class="mozTocH2" name="mozTocId281352"></a><a name="Observer_methods_OB"></a> 6.4 Observer methods
(OB)</h2>
These methods can be used by observers, operators and system programs
(but not by delegate programs).<br>
<br>
<span class="method"><a name="Input:_MT_OB_INPUT"></a>Input:
MT_OB_INPUT</span><br>
Receives input from the user.<br>
<br>
Size 1 (method registers: 4)<br>
<br>
What this method does when called depends entirely on the value of the
first method register.<br>
<br>
<span style="font-weight: bold;"><br>
Status</span><br>
<dl>
<dt>MS_OB_INPUT_MOUSE_BUTTON</dt>
</dl>
<dl>
<dd>Sets register 1 to the left mouse
button's status (a <a href="#Button_status">BUTTON_* value</a>),
sets register 2 to the right mouse button's status,
and returns the mouse's status (a <a href="#Mouse_status_values">MOUSE_STATUS_*
value</a>).</dd>
</dl>
<dl>
<dd>Example:<br>
</dd>
</dl>
<code><span class="excode">int lmb, rmb,
mouse_status;<br>
<br>
mouse_status = call(METH_INPUT, MS_OB_INPUT_MOUSE_BUTTON);<br>
<br>
if (mouse_status != MOUSE_STATUS_OUTSIDE)<br>
{<br>
&nbsp;lmb = get(METH_INPUT, 1);<br>
&nbsp;if (lmb &lt;= BUTTON_NOT_PRESSED) <span style="color: rgb(153, 153, 255);">// means that button not pressed (and also not just released)</span><br>
&nbsp; rmb = get(METH_INPUT, 2);<br>
}</span></code><span class="excode"></span><br>
MS_OB_INPUT_MODE_MOUSE_XY
<dl>
</dl>
<dl>
<dd>Sets registers 1 and 2 to the x and
y coordinates of the mouse, and returns the mouse's status. The
coordinates indicate the mouse's position in the game world (in
pixels), not on screen, so you do not need to adjust for camera
position.</dd>
</dl>
<dl>
<dt>MS_OB_INPUT_MOUSE_SCREEN_XY</dt>
</dl>
<dl>
<dd>Like MS_OB_INPUT_MODE_MOUSE_XY,
but the coordinates give the mouse's position on the game display, with 0,0 being the top left corner.</dd>
</dl>
<dl>
<dt>MS_OB_INPUT_MOUSE_MAP_XY</dt>
</dl>
<dl>
<dd>Like MS_OB_INPUT_MODE_MOUSE_XY, but
only works if the mouse is over the map. The coordinates indicate the
position in the game world that corresponds to the mouse's position on
the map.</dd>
</dl>
MS_OB_INPUT_KEY
<dl>
<dd>Returns the status of a key (using one of
the <a href="#Button_status">BUTTON_* values</a>
also used for mouse button status). The key should
be specified in register 1 as one of the KEY_* values (see <a href="#Appendix_A:_Key_codes">Appendix A: Key codes</a>).</dd>
</dl>
<dl>
<dd>Example:<br>
</dd>
</dl>
<code><span class="excode">int is_a_pressed;<br>
<br>
is_a_pressed = call(METH_INPUT, MS_OB_INPUT_KEYBOARD, KEY_A);</span></code><br><dl><dt>
MS_OB_INPUT_ANY_KEY</dt></dl><dl><dd>Checks
for any key being pressed, and returns its KEY_* value (or -1 if no key
being pressed). Also sets register 0 to the key's BUTTON_* status.</dd></dl><dl><dd>If multiple keys are being pressed, it just returns one of them.</dd></dl>
<br>
<span style="font-weight: bold;"><a name="Mouse_status_values"></a>Mouse status values</span>
(returned by all mouse method calls)<br>
<dl>
<dt>MOUSE_STATUS_OUTSIDE</dt>
</dl>
<dl>
<dd>The mouse is outside the game area (e.g. on the
editor panel, or outside the game's window). In this case, no other
values (mouse button status etc.) are set.</dd>
</dl>
<dl>
<dt>MOUSE_STATUS_AVAILABLE</dt>
</dl>
<dl>
<dd>The mouse is in the game area, and none of the following
statuses apply.</dd>
</dl>
<dl>
<dt>MOUSE_STATUS_MAP</dt>
</dl>
<dl>
<dd>The mouse is over the map.</dd>
</dl>
<dl>
<dt>MOUSE_STATUS_CONSOLE</dt>
</dl>
<dl>
<dd>The mouse is over a console.</dd>
</dl>
<dl>
<dt>MOUSE_STATUS_PROCESS</dt>
</dl>
<dl>
<dd>The mouse is over the process data display.</dd>
</dl>
<br>
<span style="font-weight: bold;"><a name="Button_status"></a>Mouse
button and key status values</span><br>
<dl>
<dt>BUTTON_JUST_RELEASED (-1)</dt>
</dl>
<dl>
<dd>The button is not being pressed, but was
being pressed until a tick ago.</dd>
</dl>
<dl>
<dt>BUTTON_NOT_PRESSED (0)</dt>
</dl>
<dl>
<dd>The button is not being pressed and was not
just released.</dd>
</dl>
<dl>
<dt>BUTTON_JUST_PRESSED (1)</dt>
</dl>
<dl>
<dd>The button was just pressed.</dd>
</dl>
<dl>
<dt>BUTTON_HELD (2)</dt>
</dl>
<dl>
<dd>The button is being held.</dd>
</dl>
<br>
<span class="method"><a name="View:_MT_OB_VIEW"></a>View:
MT_OB_VIEW</span><br>
Controls the screen and various aspects of the user interface.<br>
<br>
Size 2 (method registers: 8)<br>
<br>
What this method does when called depends&nbsp;on the value of the
first method register.<br>
<br>
<br>
<span style="font-weight: bold;">Statuses</span><br>
<dl>
<dt>MS_OB_VIEW_FOCUS_XY</dt>
</dl>
<dl>
<dd>Sets the camera position (which determines what
part of the game area the user sees). Registers 1 and 2 are x/y
coordinates, in pixels.</dd>
</dl>
<dl>
<dd>Example:<br>
</dd>
</dl>
<code><span class="excode">call(METH_VIEW,
MS_OB_VIEW_FOCUS_XY, 1000, 2000); <span style="color: rgb(153, 153, 255);">// sets the camera so
the location 1000,2000 will be in the centre of the screen.</span></span></code><br>
MS_OB_VIEW_FOCUS_PROC<br>
<dl>
<dd>Sets the camera position so a particular process
(with the index specified in register 1) is at the centre of the
screen. Does nothing if the process doesn't exist.<br>
</dd>
</dl>
<dl>
<dd>Example:<br>
</dd>
</dl>
<code><span class="excode">call(METH_VIEW,
MS_OB_VIEW_FOCUS_PROC, 50); <span style="color: rgb(153, 153, 255);">//
screen will be centred
on process 50.</span></span></code><br>
MS_OB_VIEW_PROC_DATA
<dl>
</dl>
<dl>
<dd>Opens the <a href="#data_box">process data box</a>,
and sets it to
display information about a process specified by register 1. You should
probably set the data box's location (using the next status) before
calling this.</dd>
</dl>
MS_OB_VIEW_PROC_DATA_XY
<dl>
<dd>Sets the location of the top left of the data box to the
screen location indicated by registers 1 and 2.</dd>
</dl>
<dl>
<dt>MS_OB_VIEW_SCROLL_XY</dt>
</dl>
<dl>
<dd>Moves the screen left/right (register 1) and
up/down (register 2). Won't move it past the edges of the game area.</dd>
</dl>
<dl>
<dt>MS_OB_VIEW_MAP_VISIBLE</dt>
</dl>
<dl>
<dd>Sets the map on (1) or off (0) (register 1) .</dd>
</dl>
<dl>
<dt>MS_OB_VIEW_MAP_XY</dt>
</dl>
<dl>
<dd>Sets the x/y location of the map.</dd>
</dl>
<dl>
<dt>MS_OB_VIEW_MAP_SIZE</dt>
</dl>
<dl>
<dd>Sets the size of the map. Register 1 is width and
register 2 is height (both in pixels).</dd>
</dl>
<dl>
<dt>MS_OB_VIEW_DISPLAY_SIZE</dt>
</dl>
<dl>
<dd>Gets the size of the display. When called, the method sets register 1 to the current width of the
game area of the screen, and register 2 to the height. This doesn't
include the editor panel, if it's open. Returns 1 if the display has
been resized since the last cycle (for example, if the editor panel was
just opened or closed), and 0 otherwise.</dd>
</dl>
<dl>
<dd>Example:<br>
</dd>
</dl>
<code><span class="excode">int screen_just_resized;<br>
<br>
screen_just_resized = call(METH_VIEW, MS_OB_VIEW_DISPLAY_SIZE);<br>
<br>
if (screen_just_resized)<br>
{<br>
&nbsp;print("\nScreen resized to ", get(METH_VIEW, 1), " by ",
get(METH_VIEW, 2), " pixels.");<br>
}</span></code><span class="excode"></span><br class="excode">
<br>
<dl>
<dt>MS_OB_VIEW_COLOUR_PROC</dt>
</dl>
<dl>
<dd>Changes the colours used for a player's
processes. Register 1 is the player index, register 2 is the red value
at minimum intensity, register 3 is the red value at maximum intensity,
register 4 is the green value at minimum intensity, etc. Colour values
are 0 to 255.</dd>
</dl>
<dl>
<dd>Maximum intensity is the colour used for things like
undamaged
processes. Minimum intensity is used for things like badly damaged
processes and the faint underlay thing that appears underneath a
process. The maximum intensity value for a colour can be less than the
minimum, in which case that colour component increases as the intensity decreases.</dd>
</dl>
<dl>
<dd>Example:<br>
</dd>
</dl>
<code><br class="excode">
<span class="excode">call(METH_VIEW,<br>
&nbsp;MS_OB_VIEW_COLOUR_PROC, <span style="color: rgb(153, 153, 255);">// status</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
player index (i.e. player 1)</span><br>
&nbsp;180, <span style="color: rgb(153, 153, 255);">//
red at minimum intensity</span><br>
&nbsp;10, <span style="color: rgb(153, 153, 255);">//
red at maximum intensity</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
green min</span><br>
&nbsp;50, <span style="color: rgb(153, 153, 255);">//
green max</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
blue min</span><br>
&nbsp;210); <span style="color: rgb(153, 153, 255);">//
blue max</span><br>
<span style="color: rgb(153, 153, 255);"><br>
// these settings make processes look blue (with a red underlay) when
undamaged, then redder the more damaged they get.</span></span></code><span class="excode"></span><br class="excode">
<dl>
<dd>This is&nbsp;a relatively expensive operation.</dd>
</dl>
<dl>
</dl>
<dl>
<dt>MS_OB_VIEW_COLOUR_PACKET</dt>
</dl>
<dl>
<dd>Just like MS_OB_VIEW_COLOUR_PROC, but changes
packet colours for a specified player.</dd>
</dl>
<dl>
<dt>MS_OB_VIEW_COLOUR_DRIVE</dt>
</dl>
<dl>
<dd>Changes colours produced by the MOVE method.</dd>
</dl>MS_OB_VIEW_COLOUR_BACK<dl><dd>Changes the colour of the&nbsp;background. Just uses registers 1 (red), 2 (green) and 3 (blue).</dd></dl>MS_OB_VIEW_COLOUR_BACK2<dl><dd>Changes the base colour of the hexagonal pattern in the background.&nbsp;Just uses registers 1 (red), 2 (green) and 3 (blue).</dd></dl><dl><dt>MSTATUS_OB_VIEW_SOUND</dt></dl><dl><dd>Plays
an interface sound (e.g. the blip you get when you click on a process).
Not yet fully implemented. Register 1 indicates which sample to play
(currently does nothing), register 2 indicates the tone (currently a
chromatic scale from 0 to about 40, I think), and register 3 is volume (1 to 100).</dd></dl><br><br>
<span class="method"><a name="Console:_MT_OB_CONSOLE"></a>Console:
MT_OB_CONSOLE</span><br>
Controls the consoles that display text printed by processes and other
programs.<br>
<br>
Size 1 (method registers: 4)<br>
<br>
Up to 4 consoles are available (consoles 0 to 3). For most console
method calls, register 0 is the status and register 1 is the index of
the console being affected.<br>
<br>
<br>
<span style="font-weight: bold;">Statuses</span><br>
<dl>
<dt>MS_OB_CONSOLE_OPEN</dt>
</dl>
<dl>
<dd>Opens a console.</dd>
</dl>
<dl>
<dt>MS_OB_CONSOLE_CLOSE</dt>
</dl>

<dl>
<dd>Closes a console.</dd><li></li><li>MS_OB_CONSOLE_MIN</li></dl><dl><dd>Minimises a console.</dd></dl>
<dl><dt>MS_OB_CONSOLE_STATE</dt>
</dl>
<dl>
<dd>Returns the state of a console. States are 0
(closed), 1 (open but minimised), 2 (open).</dd>
</dl>
<dl>
<dt>MS_OB_CONSOLE_GET_XY</dt>
</dl>
<dl>
<dd>Gets the on-screen location of the console. After the call,
registers
2 and 3 hold the x/y coordinates of the top left corner of the console
(if the console's header is at the top) or the bottom left corner (if
the header is at the bottom).</dd>
</dl>
<dl>
<dt>MS_OB_CONSOLE_MOVE</dt></dl><dl><dd>Sets the location of the console. Works like MS_OB_CONSOLE_GET_XY, but the other way around.</dd></dl><dl><dt>MS_OB_CONSOLE_LINES</dt>
</dl>
<dl>
<dd>Sets the number of lines in the console (when
maximised) to register 2. The maximum size is 40.</dd>
</dl>
<dl>
<dt>MS_OB_CONSOLE_ACTION_SET</dt>
</dl>
<dl>
<dd>Sets an action (see below).</dd>
</dl>
<dl>
<dt>MS_OB_CONSOLE_ACTION_CHECK</dt>
</dl>
<dl>
<dd>Checks for actions (see below).</dd>
</dl>
<dl>
<dt>MS_OB_CONSOLE_CLEAR</dt>
</dl>
<dl>
<dd>Clears a console's contents.</dd>
</dl>
MS_OB_CONSOLE_STYLE<dl><dd>Changes the style of a console to a CONSOLE_STYLE value (see below). The style value goes in register 2.</dd></dl>
<dl><dt>MS_OB_CONSOLE_OUT</dt>
</dl>
<dl>
<dd>Sets which console the calling program's standard output is sent to.</dd>
</dl>
<dl>
<dt>MS_OB_CONSOLE_ERR</dt></dl>
<dl><dd>Sets which console the calling program's error output (including errors generated by the game itself) is sent to.</dd></dl>
<dl><dt>MS_OB_CONSOLE_COLOUR</dt></dl><dl><dd>Sets the colour of a
console's text&nbsp;to one of the following values (in register 2):
COL_DGREY, COL_LGREY, COL_WHITE, COL_LBLUE, COL_DBLUE, COL_LRED,
COL_DRED, COL_LGREEN, COL_DGREEN, COL_LPURPLE, COL_DPURPLE.</dd></dl>MS_OB_CONSOLE_FONT<br><dl><dd>Sets the font of a console to one of the following (in register 2):
FONT_CODE (this is the font used in the code editor), FONT_CODE_BOLD,
FONT_BASIC (this is the default), FONT_BASIC_BOLD, FONT_BASIC_LARGE.
Also clears the console.</dd></dl><dl><dt>MS_OB_CONSOLE_BACKGROUND</dt></dl><dl><dd>Sets
the colour of the console's background (and header) to the value in
register 2. Colours are BCOL_GREY, BCOL_RED, BCOL_GREEN, BCOL_BLUE,
BCOL_YELLOW, BCOL_ORANGE, BCOL_PURPLE, BCOL_TURQUOISE, BCOL_AQUA,
BCOL_CYAN.</dd></dl><dl><dt>MS_OB_CONSOLE_TITLE</dt></dl><dl><dd>Sets the title of the console. Register 2 should hold the address of a null-terminated string. For example:</dd></dl><dl><dt><code><span class="excode">int console_name [10] = {"Commands"};<span style="color: rgb(153, 153, 255);"></span></span><br class="excode">
<span class="excode">call(METH_CONSOLE, MS_OB_CONSOLE_TITLE,
0, &amp;console_name [0]); <span style="color: rgb(153, 153, 255);">// sets the name of console 0</span></span></code><code><span class="excode"><span style="color: rgb(153, 153, 255);"></span></span></code></dt><dt></dt><dt>MS_OB_CONSOLE_LINES_USED</dt></dl><dl><dd>Returns
the number of lines that have been printed to the console (up to the
maximum number it can hold) since it was last cleared.</dd></dl><dl><dt>MS_OB_CONSOLE_OUT_SYSTEM</dt></dl><dl><dd>Sets the console to which the system program's standard output is sent.</dd></dl><dl><dt>MS_OB_CONSOLE_OUT_OBSERVER</dt></dl><dl><dd>Sets the console to which the observer's standard output is sent.</dd></dl><dl><dt>MS_OB_CONSOLE_OUT_PLAYER</dt></dl><dl><dd>Sets
the console to which standard output from a player's programs
(including client and processes) is sent. Register 1 holds the console
index and register 2 holds the player index.</dd></dl><dl><dt>MS_OB_CONSOLE_OUT2_PLAYER</dt></dl><dl><dd>Sets the console to which a player's alternative output is sent.</dd></dl><dl><dt>MS_OB_CONSOLE_ERR_SYSTEM</dt></dl><dl><dd>Sets the console to which the system's error output is sent.</dd></dl><dl><dt>MS_OB_CONSOLE_ERR_OBSERVER</dt></dl><dl><dd>Sets the console to which the observer's error output is sent.</dd></dl><dl><dt>MS_OB_CONSOLE_ERR_PLAYER</dt></dl><dl><dd>Sets the console to which error output from a player is sent. Works like MS_OB_CONSOLE_OUT_PLAYER.</dd></dl><br>Example of using a console:<br>
<br>
<code><span class="excode">call(METH_CONSOLE,
MS_OB_CONSOLE_OPEN, 0); <span style="color: rgb(153, 153, 255);">//
opens console 0</span></span><br class="excode">
<span class="excode">call(METH_CONSOLE, MS_OB_CONSOLE_XY,
0, 50, 50); <span style="color: rgb(153, 153, 255);">//
puts console 0 at
50,50 on screen</span></span></code><br class="excode">
<br>
<span style="font-weight: bold;"><br>
<a name="Console_method:_actions"></a>Actions</span><br>
<br>
You can assign an action to a line printed to a console using the
MS_OB_CONSOLE_ACTION_SET status. If the user clicks on the line, a call
to MS_OB_CONSOLE_ACTION_CHECK will inform the observer/operator of the
action.<br>
<br>
An MS_OB_CONSOLE_ACTION_SET call applies to the most recently printed
line in the specified console (this is different to the way the
<a href="#Action:_MT_PR_ACTION">MT_PR_ACTION process method</a>
sets actions; they apply to all later lines
printed by the process). The values in registers 2 and 3 will be
set as the action values.<br>
<br>
An MS_OB_CONSOLE_ACTION_CHECK call checks whether the user has clicked
on a console line with an action attached to it. It returns one of the
following values:<br>
<dl>
<dt>CONSOLE_ACTION_NONE</dt>
</dl>
<dl>
<dd>No action occurred.</dd>
</dl>
<dl>
<dt>CONSOLE_ACTION_SYSTEM</dt>
</dl>
<dl>
<dd>An action was found. The action was generated by
the system program.</dd>
</dl>
<dl>
<dt>CONSOLE_ACTION_OBSERVER</dt>
</dl>
<dl>
<dd>An action generated by the observer program
was found.</dd>
</dl>
<dl>
<dt>CONSOLE_ACTION_OPERATOR</dt>
</dl>
<dl>
<dd>An action generated by the operator program
was found.</dd>
</dl>
<dl>
<dt>CONSOLE_ACTION_PROCESS</dt>
</dl>
<dl>
<dd>An action generated by a process was found.</dd>
</dl>
Note that there is no way for a delegate program to generate an action.<br>
<br>
If an action generated by a system, observer or operator was found, the
registers will be set as follows:<br>
Register 0: the console that the line was in.<br>
Register 1: the first value of the action.<br>
Register 2: the second value of the action.<br>
<br>
If an action generated by a process was found, the registers will be
set as follows:<br>
Register 0: the console that the line was in.<br>
Register 1: the index of the player who controls the process (0-3).<br>
Register 2: the index of the process.<br>
Register 3: the value the process set for the action.<br>
<br>
Every line printed by a process automatically attaches an action with a
value of 0 (the observer and operator programs that come with the game
use this to focus on a process when the user clicks on a line printed
by the process). The process can set a different value using the
<a href="#Action:_MT_PR_STD">MT_PR_STD method</a>.<br>
<br>
Example:<br>
<br>
<code><span class="excode"><span style="color: rgb(153, 153, 255);">// setting the action:</span><br>
print("\n &gt;&gt; click here to send an action!
&lt;&lt;");<br>
call(METH_CONSOLE, MS_OB_CONSOLE_ACTION_SET, 0, 100, 200);<br>
<span style="color: rgb(153, 153, 255);">// This adds an
action to the line just printed to console 0.</span><br style="color: rgb(153, 153, 255);">
<br style="color: rgb(153, 153, 255);">
<span style="color: rgb(153, 153, 255);">// checking for
an action:</span><br style="color: rgb(153, 153, 255);">
int action_detected, source_console, action_value1, action_value2;<br>
<br>
action_detected = call(METH_CONSOLE,
MS_OB_CONSOLE_ACTION_CHECK);&nbsp;<span style="color: rgb(153, 153, 255);"></span><br>
<br>
if (action_detected == CONSOLE_ACTION_OPERATOR)<br>
{<br>
&nbsp;source_console = get(METH_CONSOLE, 0);<br>
&nbsp;action_value1 = get(METH_CONSOLE, 1);<br>
&nbsp;action_value2 = get(METH_CONSOLE, 2);<br>
}<br>
<span style="color: rgb(153, 153, 255);">//
if the user clicked on the line set above in this example,
source_console would be 0, action_value1 would be 100 and
action_value2 would be 200</span></span></code><span class="excode"></span><br><span style="font-weight: bold;"><br>Console styles<br><span style="font-weight: bold;"><br></span></span>The following styles are available:<br><dl><dt>CONSOLE_STYLE_BASIC</dt></dl><dl><dd>A basic top-down scrollable console.</dd></dl><dl><dt>CONSOLE_STYLE_BASIC_UP</dt></dl><dl><dd>Like BASIC, but the header is at the bottom of the console and the rest of the console extends upwards from it.</dd></dl><dl><dt>CONSOLE_STYLE_CLEAR_CENTRED</dt></dl><dl><dd>The console is just lines of centred text, with no background.</dd></dl><dl><dt>CONSOLE_STYLE_BOX</dt></dl><dl><dd>A non-scrollable box.</dd></dl><dl><dt>CONSOLE_STYLE_BOX_UP</dt></dl><dl><dd>Like BOX but the console extends upwards.</dd></dl><span style="font-weight: bold;"><span style="font-weight: bold;"></span></span>
<br>
<span class="method"><a name="Select:_MT_OB_SELECT"></a>Select:
MT_OB_SELECT</span><br>
Adds some minor graphic elements to the user interface. There can be up to 64 markers active at once.<br>
<br>
Size 1 (method registers: 4)<br>
<br>
<span style="font-weight: bold;"><br>
Statuses</span><dl><dt>MS_OB_SELECT_SET_MARKER</dt>
</dl>
<dl>
<dd>Creates a marker, and returns the index of the newly created marker (or -1 if there are no markers left).&nbsp;</dd>
</dl><dl><dd>Register 1&nbsp;sets the marker type, register 2 is how
many ticks the
marker lasts for, and register 3 is the colour.&nbsp;After you set a
marker, you need to place it as well, using one of the following calls.</dd>
</dl><dl><dd>The colour should be one of BCOL_GREY, BCOL_RED,
BCOL_GREEN, BCOL_BLUE, BCOL_YELLOW, BCOL_ORANGE, BCOL_PURPLE,
BCOL_TURQUOISE, BCOL_AQUA or BCOL_CYAN.</dd></dl>
<dl>
<dt>MS_OB_SELECT_PLACE_MARKER</dt>
</dl>
<dl>
<dd>Places a marker at a
specified location. Register 1 is the marker's index, register 2 is x (world coordinates, not screen
coordinates) and register 3 is y.</dd>
</dl>
<dl>
<dt>MS_OB_SELECT_PLACE_MARKER2</dt>
</dl>
<dl>
<dd>Used for markers with two sets of coordinates (boxes and lines). Sets the
second set of coordinates&nbsp;(register 1 is index, register 2 is x, register 3 is y). If the marker is a box, this corner
can be in any direction from the first corner (it doesn't have to be
the bottom right of the box).</dd>
</dl>
<dl>
<dt>MS_OB_SELECT_BIND_MARKER</dt>
</dl>
<dl>
<dd>Binds a marker to a
process (marker index in register 1; process index in register 2). If
the marker has two sets of coordinates, this binds the first set to the
process.</dd></dl><dl><dt>MS_OB_SELECT_BIND_MARKER2</dt></dl>
<dl><dd>Binds the second set of coordinates of a line marker to a
process&nbsp;(marker index in register 1; process index in register 2).</dd></dl><dl><dt>MS_OB_SELECT_UNBIND_PROCESS</dt></dl><dl><dd>Removes all markers from a process (index in register 1).</dd></dl><dl><dt>MS_OB_SELECT_CLEAR_ALL</dt></dl><dl><dd>Clears all markers, with no transition animations (i.e. markers disappear instantaneously instead of fading out).</dd></dl><dl><dt>MS_OB_SELECT_EXPIRE_ALL</dt></dl><dl><dd>Causes all markers to expire, showing transition animations.</dd></dl><dl><dt>MS_OB_SELECT_CLEAR</dt></dl><dl><dd>Clears a single marker (index in register 1).</dd></dl><dl><dt>MS_OB_SELECT_EXPIRE</dt></dl><dl><dd>Causes a single marker to expire (index in register 1).</dd></dl><dl><dt>MS_OB_SELECT_MARKER_SPIN</dt></dl><dl><dd>Sets
the speed and direction a marker spins in (only relevant for the
markers that do actually spin). Register 1 is the marker index,
register 2 is the new spin (-128 to 128).</dd></dl><dl><dt>MS_OB_SELECT_MARKER_ANGLE</dt></dl><dl><dd>Sets
the angle of a marker. Only relevant for markers that can spin.
Register 1 is the marker index, register 2 is the new angle (0 to 8192).</dd></dl><dl><dt>MS_OB_SELECT_MARKER_SIZE</dt></dl><dl><dd>Sets the size of a marker. Register 1 is marker index, register 2 is size (0 to 15).</dd></dl><dl>
</dl>
<span style="font-weight: bold;"><a name="Marker_types"></a>Marker
types</span><br>
<br>
There are currently the following kinds of markers:<br><dl>
<dt>MARKER_BASIC</dt>
</dl>
<dl>
<dd>Spinning marker with 4 inward-pointing things.</dd>
</dl>
<dl>
<dt>MARKER_BASIC_6</dt>
</dl>
<dl>
<dd>Like BASIC, but with 6 things.</dd>
</dl>
<dl>
<dt>MARKER_BASIC_8</dt></dl>
<dl><dd>Like BASIC, but with 8 things.</dd></dl>
MARKER_PROC_BOX<dl><dd>Draws a box around a process. Base size depends on the process' size.</dd></dl>MARKER_CORNERS<br><dl><dd>Little outward-pointing arrow things.</dd></dl>MARKER_SHARP<br><dl><dd>Like BASIC, but with pointier things.</dd></dl><dl><dt>MARKER_SHARP_5</dt></dl><dl><dd>Like BASIC, but with 5 pointier things.</dd></dl>
<dl><dt>MARKER_SHARP</dt></dl><dl><dd>Like BASIC, but with 7 pointier things.</dd></dl>
<dl>
</dl>
<dl>
<dt>MARKER_BOX</dt></dl><dl><dd>A&nbsp;box that appears on the game display (e.g. used for selecting groups of processes). Uses both sets of coordinates.</dd></dl><dl><dt>MARKER_MAP_POINT</dt></dl><dl><dd>A point that appears on the map only.</dd><li></li><li>MARKER_MAP_AROUND_1</li></dl><dl><dd>Another kind of map marker.</dd></dl>MARKER_MAP_AROUND_2<br><dl><dd>Another kind of map marker.</dd></dl>MARKER_MAP_CROSS<dl>
</dl>
<dl><dd>Another kind of map marker.</dd></dl><dl><dt>MARKER_MAP_LINE</dt></dl><dl><dd>A line that appears on the map. Uses both sets of coordinates.</dd></dl><dl><dt>MARKER_MAP_BOX</dt></dl><dl><dd>A box that appears on the map. Uses both sets of coordinates.</dd></dl><br>
Example:<br>
<br>
<code><span class="excode">int marker, map_marker;<br><br>marker = call(METH_SELECT,
MS_OB_SELECT_SET_MARKER, MARKER_BASIC, 32, BCOL_YELLOW);<br>
call(METH_SELECT, MS_OB_SELECT_PLACE_MARKER, marker, 1000, 3000);<br>map_marker = call(METH_SELECT, MS_OB_SELECT_SET_MARKER, MARKER_MAP, 32);<br>
call(METH_SELECT, MS_OB_SELECT_PLACE_MARKER, map_marker, 1000, 3000);<br>
</span><span class="excode"></span><br class="excode">
<span style="color: rgb(153, 153, 255);" class="excode">//
This puts two markers at the location 1000,3000. One will be
displayed on the screen, and the other will be displayed on the map.
Both will last for about a second (32 ticks).<br>//
If a new marker can't be set (because there are already 64 markers),
the _SET_MARKER call will return -1 and the PLACE_MARKER calls will
just do nothing.<br></span></code><br>Example:<br>
<br>
<code><span class="excode">int marker;<br><br>marker = call(METH_SELECT,
MS_OB_SELECT_SET_MARKER, MARKER_BOX, 1, BCOL_GREY);<br>
call(METH_SELECT, MS_OB_SELECT_PLACE_MARKER, marker, 500, 800);<br>
call(METH_SELECT, MS_OB_SELECT_PLACE_MARKER2, marker, 700, 1000);</span><span class="excode"></span><br class="excode">
<span style="color: rgb(153, 153, 255);" class="excode">//
This puts a box with corners at 500,800 and 700,1000. It will last
for a single tick.</span></code><br>
<br>
<span class="method"><a name="Control:_MT_OB_CONTROL"></a>
Control: MT_OB_CONTROL</span><br>
Gives the observer some information about the game and allows it to
communicate with the system program.<br>
<br>
Size 1 (method registers: 4)<br>
<br>
<span style="font-weight: bold;"><br>
Statuses</span><br>
<dl>
<dt>MS_OB_CONTROL_PAUSED</dt>
</dl>
<dl>
<dd>Returns 1 if the game is paused, 0 otherwise.
Can't be used to tell if&nbsp;the game is halted rather than paused
(as the observer
won't be running if it's halted).</dd>
</dl>
MS_OB_CONTROL_PAUSE_SET<br>
<dl>
<dd>Turns pause on (if register 1 is 1) or off (if
register 1 is 0)</dd>
</dl>
<dl>
<dt>MS_OB_CONTROL_FF</dt>
</dl>
<dl>
<dd>Returns 1 if the game is fast-forwarding, 0 otherwise.</dd>
</dl>
MS_OB_CONTROL_FF_SET
<dl>
<dd>Turns fast forward on (if register 1 is 1) or off
(if register 1 is 0).</dd>
</dl>
<dl>
<dd>Register 2 determines the fast forward mode: 0 means smooth
fast
forward mode (the game unlocks the frame rate and runs as fast as it
can),&nbsp;1 means skippy mode (the game displays 1 frame per second and
between those frames runs as fast as possible), 2 means 4x speed (only 1 in 4 frames is displayed), 3 means 8x speed.</dd>
</dl>
MS_OB_CONTROL_PHASE
<dl>
</dl>
<dl>
<dd>Returns the game phase (see game phases)</dd>
</dl>
<dl>
<dt>MS_OB_CONTROL_SYSTEM_SET</dt>
</dl>
<dl>
<dd>Allows the observer to communicate with the
system program. There are 64 shared registers that both can use (the
system program can use them with the <a href="#Manage:_MT_SY_MANAGE">MT_SY_MANAGE
method</a>). Register 1
is the register index, register 2 is the value to set it to.</dd>
</dl>
<dl>
<dt>MS_OB_CONTROL_SYSTEM_READ</dt>
</dl>
<dl>
<dd>Returns the value of a system/observer
shared register. Register 1 (of the method) is the register index.</dd>
</dl>
<dl>
<dt>MS_OB_CONTROL_TURN</dt>
</dl>
<dl>
<dd>Returns the current turn. Returns -1 if the game
doesn't have turns.</dd>
</dl>
<dl>
<dt>MS_OB_CONTROL_TURNS</dt>
</dl>
<dl>
<dd>Returns the number of turns in the game. Returns
-1 if there is no specific limit, or if the game doesn't have turns.</dd>
</dl>
<dl>
<dt>MS_OB_CONTROL_SECONDS_LEFT</dt>
</dl>
<dl>
<dd>Returns the number of seconds left in the
current turn.</dd>
</dl>
<dl>
<dt>MS_OB_CONTROL_TICKS_LEFT</dt>
</dl>
<dl>
<dd>Returns the number of ticks left in the
current turn, capped at 32767.</dd>
</dl>
<dl>
<dt>MS_OB_CONTROL_TURN_SECONDS</dt>
</dl>
<dl>
<dd>Returns the total number of seconds in a
turn.</dd>
</dl>
<br>
<br>
<h2><a class="mozTocH2" name="mozTocId325090"></a><a name="System_methods_SY"></a> 6.5 System methods (SY)</h2>
These methods can only be used by the system program.<br>
<br>
<span class="method"><a name="Place:_MT_SY_PLACE"></a>Place:
MT_SY_PLACE</span><br>
Places processes in the world. Similar to the <a href="#New:_MT_PR_NEW">MT_PR_NEW method</a>, but the
system program can put processes anywhere and doesn't have to worry
about data costs.<br>
<br>
Size 2 (method registers: 8)<br>
<br>
<span style="font-weight: bold;"><br>
Registers</span><br>
<dl>
<dt>MB_SY_PLACE_STATUS</dt>
</dl>
<dl>
<dd>Type of call. After a new process is successfully
created, holds the index of the new process. Also holds the data or
irpt cost of creating a new process after a cost query.</dd>
</dl>
<dl>
<dt>MB_SY_PLACE_X</dt>
</dl>
<dl>
<dd>x location of new process.</dd>
</dl>
<dl>
<dt>MB_SY_PLACE_Y</dt>
</dl>
<dl>
<dd>y location.</dd>
</dl>
<dl>
<dt>MB_SY_PLACE_ANGLE</dt>
</dl>
<dl>
<dd>Angle of new process.</dd>
</dl>
<dl>
<dt>MB_SY_PLACE_ADDRESS1</dt>
</dl>
<dl>
<dd>Start address of new process' bcode (in the
system program itself, or in a template).</dd>
</dl>
<dl>
<dt>MB_SY_PLACE_ADDRESS2</dt>
</dl>
<dl>
<dd>End address.</dd>
</dl>
<dl>
<dt>MB_SY_PLACE_INDEX</dt>
</dl>
<dl>
<dd>Which player will control the process.</dd>
</dl>
<dl>
<dt>MB_SY_PLACE_TEMPLATE</dt>
</dl>
<dl>
<dd>If reading bcode from a template, this is the
template (uses different indices from the MT_PR_NEW method, because the
system program can use all templates - see below).</dd>
</dl>
<br>
<span style="font-weight: bold;">Statuses</span><br>
<dl>
<dt>MS_SY_PLACE_NOTHING</dt>
</dl>
<dl>
<dd>Does nothing.</dd>
</dl>
<dl>
<dt>MS_SY_PLACE_BC_CALL</dt>
</dl>
<dl>
<dd>Places a new process, with the new process' bcode
being copied from the system program.</dd>
</dl>
<dl>
<dt>MS_SY_PLACE_BC_CALL_TEST</dt>
</dl>
<dl>
<dd>Tests whether it's possible to create a new
process.</dd>
</dl>
<dl>
<dt>MS_SY_PLACE_BC_COST_DATA</dt>
</dl>
<dl>
<dd>Gets the data cost (the cost will be in the
status register).</dd>
</dl>
<dl>
<dt>MS_SY_PLACE_BC_COST_IRPT</dt>
</dl>
<dl>
<dd>Irpt cost.</dd>
</dl>
<dl>
<dt>MS_SY_PLACE_T_CALL</dt>
</dl>
<dl>
<dd>Like MS_SY_PLACE_BC_CALL, but uses a template
instead.</dd>
</dl>
<dl>
<dt>MS_SY_PLACE_T_CALL_TEST</dt>
</dl>
<dl>
<dd>Test template.</dd>
</dl>
<dl>
<dt>MS_SY_PLACE_T_COST_DATA</dt>
</dl>
<dl>
<dd>Data cost of placing from template.</dd>
</dl>
<dl>
<dt>MS_SY_PLACE_T_COST_IRPT</dt>
</dl>
<dl>
<dd>Irpt cost of placing from template.</dd>
</dl>
<br>
<span style="font-weight: bold;"><a name="Template_indices"></a>Template indices</span><br>
<br>
When placing from a template, the following values can be used in the
MB_SY_PLACE_TEMPLATE register:<br>
<br>
TEMPLATE_OBSERVER<br>
TEMPLATE_P0_CLIENT<br>
TEMPLATE_P1_CLIENT<br>
TEMPLATE_P2_CLIENT<br>
TEMPLATE_P3_CLIENT<br>
TEMPLATE_P0_PROCESS_0<br>
TEMPLATE_P0_PROCESS_1<br>
TEMPLATE_P0_PROCESS_2<br>
TEMPLATE_P0_PROCESS_3<br>
TEMPLATE_P1_PROCESS_0<br>
TEMPLATE_P1_PROCESS_1<br>
TEMPLATE_P1_PROCESS_2<br>
TEMPLATE_P1_PROCESS_3<br>
TEMPLATE_P2_PROCESS_0<br>
TEMPLATE_P2_PROCESS_1<br>
TEMPLATE_P2_PROCESS_2<br>
TEMPLATE_P2_PROCESS_3<br>
TEMPLATE_P3_PROCESS_0<br>
TEMPLATE_P3_PROCESS_1<br>
TEMPLATE_P3_PROCESS_2<br>
TEMPLATE_P3_PROCESS_3<br><br>
When called, the method will return one of the <a href="#MR_NEW_values">MR_NEW_* values</a> (which
are also used by the <a href="#New:_MT_PR_NEW">MT_PR_NEW
method</a>).<br>
<br>
Example:<br>
<br>
<code><span class="excode">int place_result,
new_process_index;<br>
<br>
place_result = call(METH_PLACE,<br>
&nbsp;MS_SY_PLACE_BC_CALL, <span style="color: rgb(153, 153, 255);">// status: copies new
process from the system program</span><br>
&nbsp;2000, <span style="color: rgb(153, 153, 255);">//
x coordinate (absolute)</span><br>
&nbsp;2000, <span style="color: rgb(153, 153, 255);">//
y coordinate</span><br>
&nbsp;ANGLE_2, <span style="color: rgb(153, 153, 255);">//
angle of new process (ANGLE_2 means 4096, or 1/2 of a full circle, so
the process' vertex 0 will be pointing left)</span><br>
&nbsp;process_start(some_process), <span style="color: rgb(153, 153, 255);">// some_process is a
subprocess of the system program</span><br>
&nbsp;process_end(some_process),<br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
new process will belong to player 1</span><br>
&nbsp;0); <span style="color: rgb(153, 153, 255);">//
template index - not used</span><br style="color: rgb(153, 153, 255);">
<br>
if (place_result == MR_NEW_SUCCESS)<br>
{<br>
&nbsp;new_process_index = get(METH_PLACE, MB_SY_PLACE_STATUS); <span style="color: rgb(153, 153, 255);">// on success, the status
register holds the new process' index</span><br>
&nbsp;call(METH_MODIFY, MS_SY_MODIFY_INSTANT, new_process_index);<span style="color: rgb(153, 153, 255);"> // makes new process
appear instantly, without fading in</span><br>
}</span></code><span class="excode"></span><br>
Another example:<br>
<br>
<code><span class="excode">int place_result;<br>
<br>
place_result = call(METH_PLACE,<br>
&nbsp;MS_SY_PLACE_T_CALL, <span style="color: rgb(153, 153, 255);">// status: copies new
process from a template</span><br>
&nbsp;3000, <span style="color: rgb(153, 153, 255);">//
x</span><br>
&nbsp;3000, <span style="color: rgb(153, 153, 255);">//
y</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
angle (0 is right)</span><br>
&nbsp;0, <span style="color: rgb(153, 153, 255);">//
start address</span><br>
&nbsp;BCODE_SIZE_PROCESS - 1, <span style="color: rgb(153, 153, 255);">// end address - this is
the final address in a process template</span><br>
&nbsp;1, <span style="color: rgb(153, 153, 255);">//
player 2</span><br>
&nbsp;TEMPLATE_P2_PROCESS_0); <span style="color: rgb(153, 153, 255);">// uses player 2's
process template 0</span><br>
<br>
<span style="color: rgb(153, 153, 255);">//
copying from address 0 to address (BCODE_SIZE_PROCESS - 1) uses the
entire template. It's possible to only use part of a template by
specifying different addresses, if you know what you're doing</span></span></code><span class="excode"></span><br>
<br>
<span class="method"><a name="Template:_MT_SY_TEMPLATE"></a>Template:
MT_SY_TEMPLATE</span><br>
Allows the system program to copy code from itself to templates.<br>
<br>
Size 1 (method registers: 4)<br>
<br>
<span style="font-weight: bold;"><br>
Registers</span><br>
<dl>
<dt>MB_SY_TEMPLATE_TYPE</dt>
</dl>
<dl>
<dd>Target template. Should be one of the <a href="#Template_indices">TEMPLATE_*
macros</a>. Note that loading&nbsp;code into an observer or
client template
doesn't change the currently loaded observer or client; the <a href="#Manage:_MT_SY_MANAGE">MANAGE
method</a> must load it.&nbsp;</dd>
</dl>
<dl>
<dt>MB_SY_TEMPLATE_START</dt>
</dl>
<dl>
<dd>Start address of the bcode to be copied from the
system program.</dd>
</dl>
<dl>
<dt>MB_SY_TEMPLATE_END</dt>
</dl>
<dl>
<dd>End address.</dd>
</dl>
<dl>
<dt>MB_SY_TEMPLATE_NAME</dt>
</dl>
<dl>
<dd>Address of the start of a null-terminated string,
which will show up in the template menu as the template's name. If this
is 0, the name will just be "Unnamed".</dd>
</dl>
Example:<br>
<br>
<code><span class="excode">process a_process; <span style="color: rgb(153, 153, 255);">// assume this is defined
elsewhere in the system program</span><br>
<br>
int process_name [20] = {"a process"}; <span style="color: rgb(153, 153, 255);">// template name can be
up to 20 characters</span><br>
<br>
call(METH_TEMPLATE,<br>
&nbsp;TEMPLATE_P1_PROCESS_0, <span style="color: rgb(153, 153, 255);">// copies to player 1's
first process template</span><br>
&nbsp;process_start(a_process),<br>
&nbsp;process_end(a_process),<br>
&nbsp;&amp;process_name [0]);<span style="color: rgb(153, 153, 255);"></span></span></code><span class="excode"></span><br>
<br>
<span class="method"><a name="Modify_process:_MT_SY_MODIFY"></a>Modify
process: MT_SY_MODIFY</span><br>
Allows the system program to modify processes in various ways.<br>
<br>
Size 1 (method registers: 4)<br>
<br>
<span style="font-weight: bold;"><br>
Registers</span><br>
<dl>
<dt>MB_SY_MODIFY_PROC_STATUS</dt>
</dl>
<dl>
<dd>Status.</dd>
</dl>
<dl>
<dt>MB_SY_MODIFY_PROC_INDEX</dt>
</dl>
<dl>
<dd>Index of process to modify.</dd>
</dl>
<dl>
<dt>MB_SY_MODIFY_PROC_VALUE</dt>
</dl>
<dl>
<dd>New value.</dd>
</dl>
<dl>
<dt>MB_SY_MODIFY_PROC_VALUE2</dt>
</dl>
<dl>
<dd>New value2.</dd>
</dl>
<span style="font-weight: bold;"><br>
Statuses</span><br>
<dl>
<dt>MS_SY_MODIFY_HP</dt>
</dl>
<dl>
<dd>Changes a process' hp to new value (bounds-checked
from 1 to max hp - this can't be used to destroy a process).</dd>
</dl>
<dl>
<dt>MS_SY_MODIFY_IRPT</dt>
</dl>
<dl>
<dd>Changes a process' irpt to new value (bounds-checked
from 0 to max irpt).</dd>
</dl>
<dl>
<dt>MS_SY_MODIFY_DATA</dt>
</dl>
<dl>
<dd>Changes a process' data to new value (bounds-checked
from 0 to max data).</dd>
</dl>
<dl>
<dt>MS_SY_MODIFY_MB</dt>
</dl>
<dl>
<dd>Changes a method register (specified by
MB_SY_MODIFY_PROC_VALUE) of a process to
new value2.</dd>
</dl>
<dl>
<dt>MS_SY_MODIFY_BCODE</dt>
</dl>
<dl>
<dd>Changes bcode address (specified by
MB_SY_MODIFY_PROC_VALUE)
of a process to
new value2.</dd>
</dl>
<dl>
<dt>MS_SY_MODIFY_INSTANT</dt>
</dl>
<dl>
<dd>If called just after a process is newly placed,
this prevents the fade-in effect and makes the process just appear. The
value registers are not used.</dd>
</dl>
Examples:<br>
<br>
<code><span class="excode">call(METH_MODIFY,<br>
&nbsp;MS_SY_MODIFY_HP,<br>
&nbsp;100, <span style="color: rgb(153, 153, 255);">//
affects process 100</span><br>
&nbsp;1); <span style="color: rgb(153, 153, 255);">//
process will have 1 hp</span><br>
<br>
call(METH_MODIFY,<br>
&nbsp;MS_SY_MODIFY_BCODE,<br>
&nbsp;100, <span style="color: rgb(153, 153, 255);">//
affects process 100</span><br>
&nbsp;1200, <span style="color: rgb(153, 153, 255);">//
affects bcode address 1200</span><br>
&nbsp;0); <span style="color: rgb(153, 153, 255);">//
new bcode value is 0</span><br>
<br>
call(METH_MODIFY,<br>
&nbsp;MS_SY_MODIFY_INSTANT,<br>
&nbsp;100);<span style="color: rgb(153, 153, 255);">
// affects process 100</span></span></code><span class="excode"></span><br>
<br>
<br>
<span class="method"><a name="Manage:_MT_SY_MANAGE"></a>Manage:
MT_SY_MANAGE</span><br>
An essential method for system programs that allows them to run the
game.<br>
<br>
Size 1 (method registers: 4)<br>
<br>
<span style="font-weight: bold;"><br>
Statuses</span><br>
<dl>
<dt>MS_SY_MANAGE_PAUSED</dt>
</dl>
<dl>
<dd>Returns 1 if the game is paused or 0 if not (while
paused, system, observer and operator programs continue to
run).&nbsp;Can't be used to tell if&nbsp;the game is halted
rather than
paused (as the system program
won't be running if it's halted).</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_PAUSE_SET</dt>
</dl>
<dl>
<dd>Turns pause on (if register 1 is 1) or off (if
register 1 is 0). Note that the <a href="#Control:_MT_OB_CONTROL">MT_OB_CONTROL
method</a> can set pause as well.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_FF</dt>
</dl>
<dl>
<dd>Returns 1 if the game is running in fast forward, 0 if
not</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_FF_SET</dt>
</dl>
<dl>
<dd>Turns fast forward on (if register 1 is 1) or off
(if register 1 is 0).</dd>
</dl>
<dl>
<dd>Register 2 determines the fast forward mode: 0 means smooth
fast
forward mode (the game unlocks the frame rate and runs as fast as it
can), and 1 means skippy mode (the game displays 1 frame per second and
between those frames runs as fast as possible).</dd>
</dl>
<dl>
<dd>Note that the <a href="#Control:_MT_OB_CONTROL">MT_OB_CONTROL
method</a> can set fast forward as well. </dd>
</dl>
MS_SY_MANAGE_PHASE
<dl>
</dl>
<dl>
<dd>Returns the current game phase.</dd>
</dl>
MS_SY_MANAGE_OB_SET<br>
<dl>
<dd>Allows the&nbsp;system program to communicate with the
observer/operator. There are 64 shared registers that both can use (the
observer/operator&nbsp; can use them with the <a href="#Control:_MT_OB_CONTROL">MT_OB_CONTROL
method</a>). Register 1
is the register index, register 2 is the value to set it to.<br>
</dd>
</dl>
MS_SY_MANAGE_OB_READ<br>
<dl>
<dd>Returns the value of a system/observer
shared register. Register 1 (of the method) is the register index.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_TURN</dt>
</dl>
<dl>
<dd>Returns which turn it is.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_TURNS</dt>
</dl>
<dl>
<dd>Returns how many turns the game has.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_SECONDS_LEFT</dt>
</dl>
<dl>
<dd>Returns how many seconds there are left in the current turn.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_TICKS_LEFT</dt>
</dl>
<dl>
<dd>Returns how many ticks are left in the current turn.
Returns 32767 if more than 32767 ticks are left.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_TURN_SECONDS</dt>
</dl>
<dl>
<dd>Returns how many seconds there are in a turn.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_GAMEOVER</dt>
</dl>
<dl>
<dd>Finishes the game. Register 1 is the game end state.
Register 2 is also relevant to some states.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_END_PREGAME</dt>
</dl>
<dl>
<dd>If the game is in the PHASE_PREGAME, this ends it.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_END_TURN</dt>
</dl>
<dl>
<dd>If the game is in the PHASE_WORLD phase, this ends the
current turn. If this is the last turn, the game will be ended with
status GAME_END_TIME.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_START_TURN</dt>
</dl>
<dl>
<dd>If the game is in the PHASE_TURN phase, this starts the
next turn and enters PHASE_WORLD phase.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_LOAD_OBSERVER</dt>
</dl>
<dl>
<dd>Loads the&nbsp;observer template into the actual
observer program.</dd>
</dl>
<dl>
<dt>MS_SY_MANAGE_LOAD_CLIENT</dt>
</dl>
<dl>
<dd>Loads a player's client template. Register 1 is the player
index.</dd>
</dl>MS_SY_MANAGE_ALLOCATE_EFFECT
<dl><dd>Sets what a player's allocate methods do to the background
hexagons. Register 1 is the player index, register 2 is the effect (0 =
disrupt, which disrupts the hexagons randomly, and 1 = align, which
aligns the hexagons).</dd></dl>
<span style="font-weight: bold;"><br></span><span style="font-weight: bold;">
Game phases</span><br>
<br>
PHASE_WORLD
<dl>
<dd>The game is running, processes are executing etc.&nbsp;</dd>
<dd></dd>
<dd>This phase ends when time runs out, or when the system
program calls the MANAGE method with
status&nbsp;MS_SY_MANAGE_END_TURN.</dd>
</dl>
<dl>
<dt>PHASE_PREGAME</dt>
</dl>
<dl>
<dd>Before the game starts, the system program has 16 ticks
to set everything up. During this time, only the system program runs.
Processes can be placed in the world, but they don't do
anything.&nbsp;</dd>
</dl>
<dl>
<dd>This phase ends after 16 ticks, or when the system program
calls the MANAGE method with status&nbsp;
MS_SY_MANAGE_END_PREGAME. At
the end of the pregame phase the game automatically enters the turn
phase.</dd>
</dl>
<dl>
<dt>PHASE_TURN</dt>
</dl>
<dl>
<dd>Waiting for a turn to start. During this phase, system,
observer and operator programs run but delegate programs and processes
do not.&nbsp;</dd>
<dd></dd>
<dd>This phase ends when the system program calls the MANAGE
method with status&nbsp;MS_SY_MANAGE_START_TURN.</dd>
</dl>
<dl>
<dt>PHASE_OVER</dt>
</dl>
<dl>
<dd>Game has finished.</dd>
</dl>
<br>
<span style="font-weight: bold;">Game end states</span><br>
<br>
These affect the text that is shown along with the GAME OVER sign.<br>
<br>
GAME_END_BASIC
<dl>
<dd>Just shows GAME OVER.</dd>
</dl>
<dl>
<dt>GAME_END_YOU_WON</dt>
</dl>
<dl>
<dd>Tells the user that they won.</dd>
</dl>
<dl>
<dt>GAME_END_YOU_LOST</dt>
</dl>
<dl>
<dd>Tells the user that they lost.</dd>
</dl>
<dl>
<dt>GAME_END_PLAYER_WON</dt>
</dl>
<dl>
<dd>Indicates that the player specified by register 2 won.</dd>
</dl>
<dl>
<dt>GAME_END_PLAYER_LOST</dt>
</dl>
<dl>
<dd>Indicates that the player specified by register 2 lost.</dd>
</dl>
<dl>
<dt>GAME_END_DRAW</dt>
</dl>
<dl>
<dd>The game ended with a draw.</dd>
</dl>
<dl>
<dt>GAME_END_TIME</dt>
</dl>
<dl>
<dd>Ran out of time.</dd>
</dl>
<br>
<h1><a class="mozTocH1" name="mozTocId292376"></a><span class="chapter"><a name="Chapter:_Bcode_and_the_assembler"></a>
7. Bcode and the assembler</span></h1>
<span class="chapter"><br>
</span>The assembler lets you control what a program does at a
lower, more
detailed level than the compiler. You can write whole programs in
assembly language, or use bits of in-line assembler alongside compiled
code.<br>
<br>
"asm" tells the compiler to call the assembler to deal with whatever is
within the following braces. Generally, the assembler has access to
everything defined in compiled code (such as variable and function
names), but not vice-versa.<br>
<br>
You can use the "build to asm" function in the Build menu to tell the
compiler to generate assembly language instead of bcode. The asm code
will be written to a new editor tab.<br>
<br>
<h2><a class="mozTocH2" name="mozTocId401392"></a>7.1
Assembly instructions and operands</h2>
<br>
The assembler accepts a range of instructions that are translated
directly into bcode. The first 6 bits of a bcode value determine which
instruction it is; the remaining 10 bits are used to indicate register
operands (if any). Other kinds of operand are kept in the following
bcode values.<br>
<br>
Reading a value from bcode costs one instruction. Most operations have
additional costs as well. Reading a register operand from the lower
bits of an instruction has no extra cost. The cost values given for
each instruction below include the cost of reading the instruction and,
if the following bcode value contains an operand, that operand.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId555544"></a>7.1.1
Operand types</h3>
<br>
The assembler recognises the following kinds of operands:<br>
<br>
<span style="font-weight: bold;">r &lt;register&gt;</span><br>
<br>
This is one of the eight processor registers, A to H. Operations
involving the registers are fast. Each of the registers is identical;
they all hold a signed 16-bit value and can be used to perform the same
range of simple calculations and other operations.<br>
<br>
Example:<br>
<br>
<code><span class="excode">setrr A B</span></code><br>
This copies the value in register B into register A. Generally, the
first operand is the target of the instruction; it's like saying A = B.<br>
<br>
If you are writing inline asm code, the current version of the compiler
allows you to safely use registers A, B, C and D for any purpose (the
compiler is not clever enough to use them itself). The compiler uses
registers
E and F to perform calculations, register G as the stack pointer and
register H as the stack frame base pointer.<br>
<br>
A register operand has no additional cost, as it is part of the
instruction itself.<br>
<br>
Operations that result in arithmetical overflows just happen.<br>
<br>
<br>
<span style="font-weight: bold;">a &lt;address&gt;</span><br>
<br>
This uses the value in a memory address. The address can be expressed
as a literal number (like "100", although this is probably not that
useful), an identifier (like the name of a variable) or an identifier
plus a constant offset.<br>
<br>
The assembler has access to any identifier defined by the compiler that
can be resolved to a particular memory address, and because it treats
almost all kinds of identifiers in the same way (as simple references
to
memory addresses) it can use identifiers before they are declared or
defined. The
<a href="#asm:_Scoped_operands">"scope" command</a>
allows it to refer to identifiers in different address
spaces and name spaces as well.<br>
<br>
Example:<br>
<br>
<span class="excode"><code>int hello = 5;<br>
<br>
asm<br>
{<br>
setra A hello<br>
}<br>
<span style="color: rgb(153, 153, 255);">// This copies
the value 5 to register A.</span><br>
<span style="color: rgb(153, 153, 255);"></span></code></span><span class="excode"></span><span style="font-family: monospace;"><br>
</span><span class="excode"><code><br>
asm<br>
{<br>
setrn C 200<br>
setar hello_array+1 C<br>
}<br>
<span style="color: rgb(153, 153, 255);">// This copies
the value 200 to hello_array [1].<br>
<br>
</span></code></span><span class="excode"><code>int
hello_array [3];</code></span><br>
This copies the value in register C to hello_array [1].<br>
<br>
One thing that you can't use as an address operand is an automatic
local variable. You need to calculate the variable's position on the
stack first (see number operands below).<br>
<br>
Trying to use an address that is out of bounds causes the program to
exit and writes an error message to the error channel.<br>
<br>
An address operand has an additional cost of 2 (reading the address
then following it to the value in the address).<br>
<br>
<br>
<span style="font-weight: bold;">n &lt;number&gt;</span><br>
<br>
This uses a constant value. Like an address operand, the value can be a
literal number, an identifier or an identifier plus a constant offset.
If it's an identifier which can be resolved to a particular memory
address, the number will be that address. If it's an automatic
variable, the number will be the variable's stack frame offset (add
this to the stack frame base pointer to get the variable's actual
address).<br>
<br>
Examples:<br>
<br>
<code><span class="excode">setrn A 10</span></code><br>
<br>
This sets register A to 10.<br>
<br>
<code><span class="excode">int hello;<br>
<br>
asm<br>
{<br>
setrn A hello<br>
}</span></code><span class="excode"></span><br class="excode">
<br>
This sets register A to the memory address of the variable hello
(equivalent to &amp;hello).<br>
<br>
<span class="excode"><code>auto int hello_auto;<br>
<br>
hello_auto = 5;<br>
<br>
static int thing;<br>
<br>
asm<br>
{<br>
setrn A hello_auto <span style="color: rgb(153, 153, 255);">//
sets A to the stack frame offset of hello_auto</span><br>
add A A H <span style="color: rgb(153, 153, 255);">//
adds A to the stack frame base register, leaving the result in A</span><br>
setdr A A <span style="color: rgb(153, 153, 255);">//
sets A to the value in the address pointed to by itself</span><br>
setar thing A <span style="color: rgb(153, 153, 255);">//
copies the value in A to the address of thing</span><br>
}</code><br>
</span><span class="excode"></span><br>
Assuming that register H is the stack frame base pointer, the asm here
is
equivalent to:<br>
<br>
<code><span class="excode">thing = hello_auto;</span></code><br>
and demonstrates why automatic variables are much less efficient than
static variables!<br>
<br>
<code><span class="excode">label_name: <br>
&nbsp;a = 5;<br>
<br>
<span style="color: rgb(153, 153, 255);">//&nbsp;other
stuff happens here</span><br>
<br>
asm<br>
{<br>
jumpn label_name<br>
}<br>
</span><span class="excode"></span></code><br>
The jump instruction is equivalent to:<br>
<br>
<code><span class="excode">goto label_name;</span></code><br>
A number operand has an additional cost of 1 (reading the number).<br>
<br>
<br>
<span style="font-weight: bold;">d
&lt;deregister&gt;</span><br>
<br>
This operand type dereferences a register; it's like an address
operand, but the address is in a register rather than in the following
instruction.<br>
<br>
Example:<br>
<br>
<br class="excode">
<span class="excode"><code>static int hello;<br>
<br>
asm<br>
{<br>
setrn A hello<br>
setrn B 5<br>
setdr A B<br>
}</code><br>
</span><span class="excode"></span><br>
This is a (pointlessly) longer way of doing the same thing as:<br>
<br>
<span class="excode"><code>setrn A 5<br>
setar hello A</code><br>
</span><span class="excode"></span><br>
and is equivalent to:<br>
<br>
<code><span class="excode">hello = 5;</span></code><br>
A deregister operand has an additional cost of 1 (following the address
in the register).<br>
<br>
<br>
<span style="font-weight: bold;">b &lt;method
bank&gt;</span><br>
<br>
The method bank is a "bank" of 64 special registers used by a program's
methods. The &lt;method bank&gt; operand is used only by some
of the put and get instructions (and only if the method register being
used is known at assembly time). It should be a number.<br>
<br>
Example:<br>
<br>
<code><span class="excode">setrn A 5</span><br class="excode">
<span class="excode">putbr 2 A</span><br class="excode">
</code><br>
This sets method bank register 2 (which is the third register of the
first method) to the value 5. It is equivalent to the compiled code:<br>
<br>
<code><span class="excode">put(0, 2, 5);</span></code><br>
A method bank operand has no additional cost (as it is stored in six
bits of the instruction).<br>
<br>
<br>
<span style="font-weight: bold;">m &lt;method&gt;</span><br>
<br>
This is method 0 to 15. It is used only for the callmr instruction,
which calls a specified method and leaves its return value in a
register.<br>
<br>
Example:<br>
<br>
<code><span class="excode">int hello;<br>
<br>
asm<br>
{<br>
callmr 3 A<br>
setar hello A<br>
}</span></code><span class="excode"></span><br>
This calls method 3 and leaves its return value in the variable hello.
It is equivalent to:<br>
<br>
<code><span class="excode">int hello;<br>
hello = call(3);</span></code><br>
A method operand has no additional cost (as it is stored in four bits
of the instruction).<br>
<br>
<br>
<span style="font-weight: bold;">s &lt;string&gt;</span><br>
<br>
This is used only by the special print instruction "prints". The
instruction should be followed by a memory initialiser containing a
null-terminated string (the null character is added automatically).<br>
<br>
Example:<br>
<br>
<code><span class="excode">prints {"hello!"}</span></code><br>
Is equivalent to the compiled code:<br>
<br>
<code><span class="excode">print("hello!");</span></code><br>
The string is printed to the program's current console.<br>
<br>
<h2><a class="mozTocH2" name="mozTocId349731"></a>7.2
Instructions</h2>
<br>
The instructions recognised by the assembler are:<br>
<br>
<span style="font-weight: bold;">No operation</span><br>
<br>
0. nop<br>
size 1 cost 1<br>
This does nothing.<br>
<br>
<br>
<span style="font-weight: bold;">Set instructions</span><br>
<br>
1. setrr &lt;register 1&gt; &lt;register 2&gt;<br>
size 1 cost 1<br>
Copies the value in &lt;register 2&gt; to &lt;register
1&gt;.<br>
<br>
2. setra &lt;register&gt; &lt;address&gt;<br>
size 2 cost 3<br>
Copies the value in the memory address pointed to by
&lt;address&gt; to &lt;register&gt;.<br>
<br>
3. setar &lt;address&gt; &lt;register&gt;<br>
size 2 cost 3<br>
Copies the value in &lt;register&gt; to the memory address
pointed to by &lt;address&gt;.<br>
<br>
4. setrn &lt;register&gt; &lt;number&gt;<br>
size 2 cost 2<br>
Copies &lt;number&gt; to &lt;register&gt;.<br>
<br>
5. setrd &lt;register 1&gt; &lt;register 2&gt;<br>
size 1 cost 2<br>
Copies the value in the memory address pointed to by &lt;register
2&gt; to &lt;register 1&gt;.<br>
<br>
6. setdr &lt;register 1&gt; &lt;register 2&gt;<br>
size 1 cost 2<br>
Copies the value in &lt;register 2&gt; to the memory address
pointed to by &lt;register 1&gt;.<br>
<br>
<br>
<span style="font-weight: bold;">Arithmetic instructions</span><br>
<br>
7. add &lt;register 1&gt; &lt;register 2&gt;
&lt;register 3&gt;<br>
size 1 cost 2<br>
Adds &lt;register 2&gt; and &lt;register 3&gt; and puts
the result in &lt;register 1&gt;.<br>
<br>
Example:<br>
<br>
<code><span class="excode">add A B C <span style="color: rgb(153, 153, 255);">&nbsp; &nbsp;//
is equivalent to A = B + C<br>
<span style="color: white;">add A A B</span>
&nbsp; &nbsp;// is equivalent to A += B<br>
</span></span></code><br>
8. sub &lt;register 1&gt; &lt;register 2&gt;
&lt;register 3&gt;<br>
size 1 cost 2<br>
Like add, but for subtraction (&lt;register 1&gt; =
&lt;register 2&gt; - &lt;register 3&gt;).<br>
<br>
9. mul &lt;register 1&gt; &lt;register 2&gt;
&lt;register 3&gt;<br>
size 1 cost 2<br>
Like add, but for multiplication (&lt;register 1&gt; =
&lt;register 2&gt; * &lt;register 3&gt;).<br>
<br>
10. div &lt;register 1&gt; &lt;register 2&gt;
&lt;register 3&gt;<br>
size 1 cost 3<br>
Like add, but for division (&lt;register 1&gt; =
&lt;register 2&gt; / &lt;register 3&gt;). Trying to
divide by zero just returns zero.<br>
<br>
11. mod &lt;register 1&gt; &lt;register 2&gt;
&lt;register 3&gt;<br>
size 1 cost 3<br>
Like add, but gets the remainder of &lt;register 2&gt; /
&lt;register 3&gt;. Trying to divide by zero just returns zero.<br>
<br>
11. incr &lt;register&gt;<br>
size 1 cost 1<br>
Value in &lt;register&gt; is increased by 1.<br>
<br>
12. decr &lt;register&gt;<br>
size 1 cost 1<br>
Value in &lt;register&gt; is decreased by 1.<br>
<br>
<br>
<span style="font-weight: bold;">Bitwise operation
instructions</span><br>
<br>
13. and &lt;register 1&gt; &lt;register 2&gt;
&lt;register 3&gt;<br>
size 1 cost 2<br>
Like add, but for bitwise and (&lt;register 1&gt; =
&lt;register 2&gt; &amp; &lt;register 3&gt;).<br>
<br>
14. or &lt;register 1&gt; &lt;register 2&gt;
&lt;register 3&gt;<br>
size 1 cost 2<br>
Like add, but for bitwise or (&lt;register 1&gt; =
&lt;register 2&gt; | &lt;register 3&gt;).<br>
<br>
15. xor &lt;register 1&gt; &lt;register 2&gt;
&lt;register 3&gt;<br>
size 1 cost 2<br>
Like add, but for bitwise xor (&lt;register 1&gt; =
&lt;register 2&gt; ^ &lt;register 3&gt;).<br>
<br>
16. bnot &lt;register 1&gt; &lt;register 2&gt;<br>
size 1 cost 2<br>
Bitwise not. Equivalent to &lt;register 1&gt; =
~&lt;register 2&gt;.<br>
<br>
17. bshiftl &lt;register 1&gt; &lt;register 2&gt;
&lt;register 3&gt;<br>
size 1 cost 2<br>
Like add, but for left bitshift (&lt;register 1&gt; =
&lt;register 2&gt; &lt;&lt; &lt;register 3&gt;).<br>
<br>
18. bshiftr &lt;register 1&gt; &lt;register 2&gt;
&lt;register 3&gt;<br>
size 1 cost 2<br>
Like add, but for right bitshift (&lt;register 1&gt; =
&lt;register 2&gt; &gt;&gt; &lt;register 3&gt;).<br>
<br>
<br>
<span style="font-weight: bold;">Logical not</span><br>
<br>
19. not &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 1<br>
Logical not. If &lt;register2&gt; is zero,
&lt;register1&gt; is set to 1. Otherwise,
&lt;register1&gt; is set to zero. Equivalent to
&lt;register1&gt; = !&lt;register2&gt;.<br>
<br>
<br>
<span style="font-weight: bold;">Branching instructions</span><br>
<br>
20. jumpr &lt;register&gt;<br>
size 1 cost 2<br>
Jump to address stored in &lt;register&gt;. If target is out of
bounds, program exits.<br>
<br>
21. jumpn &lt;number&gt;<br>
size 2 cost 3<br>
Jump to address &lt;number&gt;. If target is out of bounds,
program exits.<br>
<br>
22. iftrue &lt;register&gt; &lt;address&gt;<br>
size 2 cost 3<br>
If &lt;register&gt; is anything other than zero, jump to
&lt;address&gt;. If target is out of bounds, program exits.<br>
<br>
23. iffalse &lt;register&gt; &lt;address&gt;<br>
size 2 cost 3<br>
If &lt;register&gt; is zero, jump to &lt;address&gt;.
If target is out of bounds, program exits.<br>
<br>
<br>
<span style="font-weight: bold;">Comparison instructions</span><br>
<br>
24. cmpeq &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 2<br>
If &lt;register1&gt; and &lt;register2&gt; contain the
same value, sets &lt;register1&gt; to 1. Otherwise, sets
&lt;register1&gt; to 0.<br>
<br>
25. cmpneq &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 2<br>
If &lt;register1&gt; and &lt;register2&gt; contain the
same value, sets &lt;register1&gt; to 0. Otherwise, sets
&lt;register1&gt; to 1.<br>
<br>
26. cmpgr &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 2<br>
If &lt;register1&gt; is greater than &lt;register2&gt;,
sets &lt;register1&gt; to 1. Otherwise, sets
&lt;register1&gt; to 0.<br>
<br>
27. cmpgre &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 2<br>
If &lt;register1&gt; is greater than or equal to
&lt;register2&gt;, sets &lt;register1&gt; to 1.
Otherwise, sets &lt;register1&gt; to 0.<br>
<br>
28. cmpls &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 2<br>
If &lt;register1&gt; is less than &lt;register2&gt;,
sets &lt;register1&gt; to 1. Otherwise, sets
&lt;register1&gt; to 0.<br>
<br>
29. cmplse &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 2<br>
If &lt;register1&gt; is less than or equal to
&lt;register2&gt;, sets &lt;register1&gt; to 1.
Otherwise, sets &lt;register1&gt; to 0.<br>
<br>
<br>
<span style="font-weight: bold;">Exit instruction</span><br>
<br>
30. exit<br>
size 1 cost 1<br>
Program exits.<br>
<br>
<br>
<span style="font-weight: bold;">Stack instructions</span><br>
<br>
31. push &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 2<br>
This is a special compound instruction that facilitates the use
of a stack. It increments &lt;register2&gt; (which should be
the stack pointer), then copies the value in &lt;register1&gt;
to the address now pointed to by &lt;register2&gt;.<br>
<br>
<code><span class="excode">push E G<br>
<span style="color: rgb(153, 153, 255);">// is equivalent
to, but slightly cheaper and smaller than:</span><br>
incr G<br>
setdr G E</span></code><br>
It occurs to me that the increment should probably come after the set.
Oh well.<br>
<br>
32. pop &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 2<br>
This is another special compound stack instruction. It copies the value
in the address pointed to by &lt;register2&gt; to
&lt;register1&gt;, then decrements
&lt;register2&gt;.&nbsp;<br>
<br>
<code><span class="excode">pop E G<br>
<span style="color: rgb(153, 153, 255);">// is equivalent
to, but slightly cheaper and smaller than:</span><br>
setrd E G<br>
decr G<br>
</span></code><br>
<br>
<span style="font-weight: bold;">Method bank instructions</span><br>
<br>
33. putbr &lt;method bank&gt; &lt;register&gt;<br>
size 1 cost 2<br>
Copies the value in &lt;register&gt; to &lt;method
bank&gt;.<br>
<br>
34. putbn &lt;method bank&gt; &lt;number&gt;<br>
size 2 cost 3<br>
Copies &lt;number&gt; to &lt;method bank&gt;.<br>
<br>
35. putba &lt;method bank&gt; &lt;address&gt;<br>
size 2 cost 4<br>
Copies the value in &lt;address&gt; to &lt;method
bank&gt;.<br>
<br>
36. putrr &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 2<br>
Copies the value in &lt;register2&gt; to the method bank
register pointed to by &lt;register1&gt;.<br>
<br>
37. putrn &lt;register&gt; &lt;number&gt;<br>
size 2 cost 3<br>
Copies &lt;number&gt; to the method bank register pointed to by
&lt;register&gt;.<br>
<br>
38. putra &lt;register&gt; &lt;address&gt;<br>
size 2 cost 4<br>
Copies the value in &lt;address&gt; to the method bank register
pointed to by &lt;register&gt;.<br>
<br>
39. getrb &lt;register&gt; &lt;method bank&gt;<br>
size 1 cost 2<br>
Copies the value in &lt;method bank&gt; to
&lt;register&gt;.<br>
<br>
40. getrr &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 2<br>
Copies the value in the method bank register pointed to by
&lt;register2&gt; to &lt;register1&gt;.<br>
<br>
<br>
<span style="font-weight: bold;"><a name="asm:_call_instructions"></a>Method call
instructions</span><br>
<br>
41. callmr &lt;method&gt; &lt;register&gt;<br>
size 1 cost 2 (this is the minimum; the actual cost depends on the cost
of calling the particular method)<br>
Calls &lt;method&gt; and leaves the result of the method call
in &lt;register&gt;.<br>
<br>
42. callrr &lt;register1&gt; &lt;register2&gt;<br>
size 1 cost 2 (actual cost depends on cost of calling the particular
method)<br>
Calls the method indicated by &lt;register1&gt; and leaves the
result of the method call in &lt;register2&gt;.<br>
<br>
<br>
<span style="font-weight: bold;">Print instructions</span><br>
<br>
43. prints &lt;string&gt;<br>
size (1 + length of string) cost (2)<br>
Prints &lt;string&gt; to the current console.
&lt;string&gt; can be up to 80 characters long, and must be
null-terminated.<br>
This instruction has a cost of only 2 regardless of how long the string
is (this is because of its value as a debugging aid; the cost may be
increased in future).<br>
<br>
44. printr &lt;register&gt;<br>
size 1 cost 2<br>
Prints the value of &lt;register&gt; to the current console as
a number.<br>
<br>
45.&nbsp;printsa &lt;address&gt;<br>
size 2 cost 3<br>
Prints a null-terminated string starting from &lt;address&gt;
to the current console.<br>
<br>
46. printsr &lt;register&gt;<br>
size 1 cost 2<br>
Prints a null-terminated string starting from the&nbsp;address
pointed to by &lt;register&gt; to the current console.<br>
<br>
<br>
<h2><a class="mozTocH2" name="mozTocId531448"></a>
7.3 Other asm instructions and directives</h2>
<h3><a class="mozTocH2" name="mozTocId193996"></a>7.3.1
Address spaces</h3>
<br>
An address space (aspace) corresponds to a compiler process. If you're
writing
inline assembler you can just ignore the difference and refer to
processes as if they were aspaces, because the compiler automatically
creates an aspace for each process. If you're writing a whole program
in assembler, you can use aspaces to define subprocesses.<br>
<br>
All identifiers defined within an aspace have a scope limited to that
aspace (and possibly further limited to an nspace within the aspace).
Also, all memory references generated by the assembler from identifiers
defined and used within an aspace will assume that the start of the
aspace is address zero. This means that code within an aspace within a
program will not run properly while it is in that program, but it will
run if the aspace is copied to a separate program so that the start of
the aspace is the start of the separate program.<br>
<br>
Aspaces can be nested within other aspaces (although not within
nspaces).<br>
<br>
It's not necessary to define an aspace for the program as a whole. Each
program has an implicit "self" aspace.<br>
<br>
The assembler recognises the following aspace commands:<br>
<dl>
<dt><span style="font-weight: bold;">def aspace
&lt;aspace name&gt;</span></dt>
</dl>
<dl>
<dd>This starts an aspace.</dd>
</dl>
<dl>
<dt><span style="font-weight: bold;">aspace_end</span></dt>
</dl>
<dl>
<dd>This ends the current aspace (you don't specify an aspace
to end; it's
always the current one).</dd>
</dl>
<dl>
<dt><span style="font-weight: bold;">aspace_end_address
&lt;aspace name&gt;</span></dt>
</dl>
<dl>
<dd>Using this as a number operand gives you the last memory
address within
the aspace (if you need the address of the start of an aspace, just use
the aspace name as a number operand).</dd>
</dl>
Example:<br>
<br>
<code><span class="excode">def aspace main_process<br>
<br>
<span style="color: rgb(153, 153, 255);">// (process
definition goes here)</span><br>
<br>
def aspace subprocess<br>
<br>
<span style="color: rgb(153, 153, 255);">// (sub-process
definition goes here)</span><br>
<br>
aspace_end // this ends subprocess<br>
aspace_end // this ends main_process</span></code><span class="excode"></span><br>
<h3><a class="mozTocH3" name="mozTocId347216"></a>
7.3.2 Name spaces</h3>
<br>
A name space (nspace) corresponds to a function. All identifiers
defined within an nspace have scope limited to that nspace. An nspace
doesn't have any effect on memory addresses, and if you are writing
assembler code you might not need to use nspaces at all. They are
really only necessary to reflect function scope in asm code generated
by the compiler.<br>
<br>
Unlike aspaces, nspaces cannot be nested.<br>
<br>
The assembler recognises the following nspace commands:<br>
<dl>
<dt><span style="font-weight: bold;">def nspace
&lt;nspace name&gt;</span></dt>
</dl>
<dl>
<dd>This starts an nspace.</dd>
</dl>
<dl>
<dt><span style="font-weight: bold;">nspace_end</span></dt>
</dl>
<dl>
<dd>This ends the current nspace (you can't specify an nspace
to end; it's
always the current one).</dd>
</dl>
<dl>
<dt><span style="font-weight: bold;">nspace_rejoin
&lt;nspace name&gt;</span></dt>
</dl>
<dl>
<dd>This re-enters a previously defined nspace in the same
aspace (the
compiler uses this to keep function code separate from static local
variable storage).<br>
</dd>
</dl>
There isn't an equivalent of aspace_end_address for nspaces, as
nspace_rejoin means that an nspace can have multiple ends. If for some
reason you need to know the end of a block of nspace code, you can put
a label there.<br>
<br>
Example:<br>
<br>
<code><span class="excode">def aspace main_process<br>
<br>
def nspace a_function<br>
<span style="color: rgb(153, 153, 255);">// (stuff)</span><br>
nspace_end <span style="color: rgb(153, 153, 255);">//
this ends a_function</span><br>
<br>
def aspace subprocess<br>
<span style="color: rgb(153, 153, 255);">// (stuff)</span><br>
aspace_end <span style="color: rgb(153, 153, 255);">//
this ends subprocess</span><br>
<br>
nspace_rejoin a_function<br>
def int local_variable {0} <span style="color: rgb(153, 153, 255);">//
this variable is within the main_process aspace and the a_function
nspace.</span><br>
nspace_end <span style="color: rgb(153, 153, 255);">//
this ends a_function again</span><br>
<br>
aspace_end <span style="color: rgb(153, 153, 255);">//
this ends main_process</span></span></code><span class="excode"></span><br>
<br>
<h3><a class="mozTocH3" name="mozTocId659438"></a><a name="asm:_Scoped_operands"></a> 7.3.3 Scoped operands</h3>
<br>
The assembler can access identifiers from outside the present process,
function, aspace or nspace using the scope command. A scoped operand
can be used before it is declared or defined, as long as it is defined
eventually.<br>
<br>
Processes and aspaces are preceded by ".", functions and nspaces are
preceded by ":" and the final identifier to be addressed is preceded by
"::".<br>
<br>
Example:<br>
<br>
<code class="excode">setar
scope.hello_process:hello_function::hello_variable A</code><br>
This copies a value from register A to a static local variable
(hello_variable) in a function (hello_function) in a process that is a
subprocess of the current process (hello_process). The address of
hello_variable that this generates is relative to the current aspace,
not the aspace of hello_process.<br>
<br>
A process or aspace used in a scope command must be a
sub-process/aspace of the current process/aspace (or a
sub-sub-process/aspace etc). If multiple layers of nested
processes/aspaces are involved, each layer must be referred to.<br>
<br>
Example:<br>
<br>
<code class="excode">setar
scope.hello_subprocess.hello_subsubprocess::hello_variable A</code><br>
This copies a value from register A to a global variable in a
sub-sub-process of the current process.<br>
<br>
Two possible uses of the scope command are:<br>
<br>
1. Accessing static local variables in other functions.<br>
<br>
2. Modifying subprocesses (as any new process created from a modified
subprocess definition will contain the modification).<br>
<br>
<h3><a class="mozTocH3" name="mozTocId764040"></a>
7.3.4 Miscellaneous</h3>
<dl>
<dt><span style="font-weight: bold;"></span></dt>
<dt><span style="font-weight: bold;">asm_only</span></dt>
</dl>
<dl>
<dd>If you put this on the first line of a process, it tells
the compiler
to expect the entire process to be a single block of assembly code. The
compiler will not generate things like an interface or a jump to the
main function; it assumes that this will all be handled by the
assembler.</dd>
</dl>
<dl>
<dt><span style="font-weight: bold;">def int
&lt;int name&gt;</span></dt>
</dl>
<dl>
<dd>This defines an identifier for the immediately following
address. To
use it as a variable, it should be followed by one or more memory
initialisers (even if the value is to be zero).</dd>
<dd></dd>
<dd>Example:</dd>
</dl>
<code><span class="excode">def int hello {5}</span></code>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;This defines a
variable (or, more
accurately for asm code, a label for a memory address) called "hello"
and initialises it to 5.
<br>
<dl>
<dd>Variables defined in asm code aren't recognised by the
compiler (this may be changed later).<br>
</dd>
</dl>
<span style="font-weight: bold;">def label &lt;label
name&gt;</span><br>
<dl>
<dd>This defines a label for the immediately following address.
There isn't
currently a difference between this and def int, but defining a label
in
this way at least indicates that you intend to use it as a jump target.</dd>
</dl>
<dl>
<dd>Example:<br>
</dd>
</dl>
<code><span class="excode">def label jump_target</span><br class="excode">
<br class="excode">
<span style="color: rgb(153, 153, 255);" class="excode">///
... (other code here)</span><br class="excode">
<br class="excode">
<span class="excode">jumpn jump_target</span></code>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;The jumpn jumps to the instruction just after the
label definition.
<dl>
<dd>When the compiler is generating asm code it will generate a
def label
command for any label it finds in the compiled code, even ones that
aren't used. You can use this to help read the generated asm.</dd>
</dl>
<span style="font-weight: bold;">memory initialisation</span>
<dl>
<dd>To initialise memory, just put the values inside braces
like this:</dd>
</dl>
<code class="excode">{0, 1, 2, 3}</code>
<dl>
<dd>This puts the numbers 0 to 3 in successive bcode
instructions. The
values are fixed at compile-time and can be modified at run-time. Note
that the program will try to execute these as code if it reaches them
(although all of these would be treated as nop instructions, as their
high 6 bits are all zero).</dd>
</dl>
<br>
<h1><a class="mozTocH1" name="mozTocId249962"></a><a name="Appendix_A:_Key_codes"></a>Appendix A: Key codes</h1>
<br>
These are used by the <a href="#Input:_MT_OB_INPUT">MT_OB_INPUT
method</a> when a key is pressed.<br>
They may assume a certain keyboard arrangement (I've only tested them
on my keyboard).<br>
<br>
KEY_0<br>
KEY_1<br>
KEY_2<br>
KEY_3<br>
KEY_4<br>
KEY_5<br>
KEY_6<br>
KEY_7<br>
KEY_8<br>
KEY_9<br>
KEY_A<br>
KEY_B<br>
KEY_C<br>
KEY_D<br>
KEY_E<br>
KEY_F<br>
KEY_G<br>
KEY_H<br>
KEY_I<br>
KEY_J<br>
KEY_K<br>
KEY_L<br>
KEY_M<br>
KEY_N<br>
KEY_O<br>
KEY_P<br>
KEY_Q<br>
KEY_R<br>
KEY_S<br>
KEY_T<br>
KEY_U<br>
KEY_V<br>
KEY_W<br>
KEY_X<br>
KEY_Y<br>
KEY_Z<br>
<br>
KEY_MINUS<br>
KEY_EQUALS<br>
KEY_SBRACKET_OPEN<br>
KEY_SBRACKET_CLOSE<br>
KEY_BACKSLASH<br>
KEY_SEMICOLON<br>
KEY_APOSTROPHE<br>
KEY_COMMA<br>
KEY_PERIOD<br>
KEY_SLASH<br>
<br>
KEY_LSHIFT<br>
KEY_RSHIFT<br>
KEY_LCTRL<br>
KEY_RCTRL<br>
<br>
KEY_UP<br>
KEY_DOWN<br>
KEY_LEFT<br>
KEY_RIGHT<br>
<br>
KEY_ENTER<br>
KEY_BACKSPACE<br>
KEY_INSERT<br>
KEY_HOME<br>
KEY_PGUP<br>
KEY_PGDN<br>
KEY_DELETE<br>
KEY_END<br>
KEY_TAB<br>
// KEY_ESCAPE (this key is unavailable - the game uses it directly)<br>
<br>
KEY_PAD_0<br>
KEY_PAD_1<br>
KEY_PAD_2<br>
KEY_PAD_3<br>
KEY_PAD_4<br>
KEY_PAD_5<br>
KEY_PAD_6<br>
KEY_PAD_7<br>
KEY_PAD_8<br>
KEY_PAD_9<br>
KEY_PAD_MINUS<br>
KEY_PAD_PLUS<br>
KEY_PAD_ENTER<br>
KEY_PAD_DELETE<br>
KEYS // total number of KEY macros<br>
<br>
<br>
</body></html>